<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Битовые маски. Динамическое программирование по маскам</title>

    <link rel="stylesheet" type="text/css" href="styles.css">

    <!-- MathJax for embedded LaTeX -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
    </script>
    <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

    <!-- Google code prettify (and a hack for displaying all line numbers). -->
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
    <style>
        .prettyprint ol.linenums > li { list-style-type: decimal; }
    </style>
</head>

<body>

<h1>Битовые маски. Динамическое программирование по маскам</h1>

<h3>Битовые маски</h3>

<p>Как известно, числа в памяти компьютера представляются в двоичной системе
счисления в виде последовательности битов. Один бит может иметь значение
$0$ или $1$. Можно провести аналогию между битами и значениями типа
<code>bool</code>: $0$ обозначает <code>false</code>, а $1$ &ndash;
<code>true</code>. По такой аналогии число (последовательность битов) можно
представить как массив значений <code>bool</code>. Например, тип <code>int</code>
может обозначать массив из $32$ значений <code>bool</code>, а <code>long long</code>
&ndash; из $64$.</p>

<p>Чаще всего массивы <code>bool</code> небольшого размера испольуются для обозначения
некоторого подмножества объектов, выбранного из множества. Например, для обозначения
элементов с индексами $1$ и $4$ (0-индексация), выбранных из множества из пяти
элементов используется массив $\{false, true, false, false, true\}$, или
$\{0, 1, 0, 0, 1\}$. Его можно представить в виде значения типа <code>int</code>:
$10010_2$ (индексация обычно начинается с младших битов числа, записываемых справа).</p>


<p>При интерпретации такого значения как обычного числа, оно будет равно
$10010_2 = 18_{10}$. Но при интерпретации его как массива логических значений
(битов), оно будет обозначать $\{0, 1, 0, 0, 1\}$. С точки зрения C++ эти два
значения равносильны, и то, является ли значение типа <code>int</code> числом,
или массивом <code>bool</code>, зависит только от контекста, в котором оно
используется.</p>

<p>При использовании значений типа <code>int</code> или <code>long long</code>
как массивов из <code>bool</code>, такие значения называются <strong>битовыми
масками</strong>.</p>

<h3>Операции с битовыми масками</h3>

<p>Для работы с масками используются побитовые операции $and, or, xor$, и
битовые сдвиги.</p>

<p>Пусть две маски обозначают два множества элементов, и нам нужно получить
маску, содержащую элементы, входящие в оба множества (<em>пересечение</em>
множеств). В новой маске <code>true</code> должны находится только в тех
позициях, где в обеих масках находились <code>true</code>. Несложно заметить,
что такое описание соответствует побитовой операции $and$:</p>

<img style="display: block; margin: auto; padding-bottom: 20px" src="resources/bit_and.png" />

<code style="display: block; text-align: center" class="prettyprint">
int c = a &amp; b;  //маска c равна пересечению масок a и b
</code>

<p>Другой распространённой операцией является <em>объединение</em> множеств.
При объединении в новой маске <code>true</code> должны находиться в тех
позициях, в которых в хотя бы одной из масок находилось <code>true</code>.
Такое описание соответствует побитовой операции $or$:</p>

<img style="display: block; margin: auto; padding-bottom: 20px" src="resources/bit_or.png" />

<code style="display: block; text-align: center" class="prettyprint">
int c = a | b;  //маска c равна объединению масок a и b
</code>

<p>Для получения значения индивидуального бита используется комбинация
битового сдвига вправо и операции $and$. Сначала нам нужно сдвинуть
биты маски так, чтобы нужный бит оказался самым младшим (находился справа).
Затем нам нужно откинуть все остальные биты маски. Реализуется это следующим
образом:</p>

<img style="display: block; margin: auto; padding-bottom: 20px" src="resources/bit_get.png" />

<code style="display: block; text-align: center" class="prettyprint">
int bit = (a >> idx) &amp; 1;  //bit равен значению idx-го бита в маске a
</code>

<p>Для установки значения определённого бита маски в <code>true</code> мы
должны применить к нему операцию $or\ true$. Реализуется это так (ко
всем остальным битам применяется $or\ false$, не имеющая никакого эффекта):</p>

<img style="display: block; margin: auto; padding-bottom: 20px" src="resources/bit_set_true.png" />

<code style="display: block; text-align: center" class="prettyprint">
int b = a | (1 &lt;&lt; idx);  //маска b - копия маски a, в которой idx-ый бит установлен в true
</code>

<p>Для изменения значения определённого бита на противоположное, нужно
применить к нему операцию $xor\ true$. Ко всем остальным битам применяется
$xor\ false$, также не имеющая никакого эффекта:</p>

<img style="display: block; margin: auto; padding-bottom: 20px" src="resources/bit_invert.png" />

<code style="display: block; text-align: center" class="prettyprint">
int b = a ^ (1 &lt;&lt; idx);  //маска b - копия маски a с противоположным значением idx-го бита
</code>

<p>Это самые распространённые операции, выполняемые с масками. Существует
множество других, здесь не приведённых, но все они основаны на $and, or, xor$,
и сдвигах.</p>

<h3>Динамическое программирование по подмножествам</h3>

<p>Битовые маски часто используются как параметры для динамического
программирования. Такой вид ДП называется ДП по маскам, или ДП по подмножествам.</p>

<p>Классической задачей на ДП по подмножествам является широко известная
<strong>задача о коммивояжёре</strong> (<em>англ.</em> TSP - Travelling
Salesman Problem). В общем виде она ставится следующим образом:</p>

<p style="display: block; margin: auto; width: 60%">
Существует $N$ городов, между некоторыми из которых есть дороги. Требуется
обойти все города, вернувшись в первый, так, чтобы длина пути была минимальной.
</p>

<p>Эта задача является классической NP-полной задачей, и ДП по подмножествам
со сложностью порядка $O(2^N * N^2)$ &ndash; её оптимальное решение.</p>

<p>Для простоты реализации примем, что города являются точками на геометрической
плоскости, и между каждой парой есть путь, длина которого равна расстоянию между
точками.</p>

<p>Обозначим за $dp[mask][i]$ &ndash; длину кратчайшего пути, проходящего через
все вершины $mask$ и заканчивающегося в вершине $i$ ($i \in mask$). Начальные
значения ДП можно записать следующим образом:</p>

$$dp[mask][i] = \infty \\
dp[\{i\}][i] = 0$$

<p>Запись $\{i\}$ обозначает маску, обозначающую множество, состоящее только из
элемента $i$.</p>

<p>Формула перехода для ДП выглядит так:</p>

$$dp[mask][i] = \min_{\substack{j\ \in\ mask \backslash i}} (dp[mask \backslash i][j] + dst(j, i))$$

<p>Запись $mask \backslash i$ обозначает множество $mask$ без элемента $i$.</p>

<p>Формула перехода обозначает следующее: чтобы попасть в вершину $i$, нужно
перейти в неё из какой-либо другой вершины $j$, также входящей в $mask$. Из
всех таких вершин нужно выбрать такую, что общая длина пути в $i$ будет
наименьшей. Общая длина пути рассчитывается как длина пути в $j$
($dp[mask \backslash i][j]$) плюс длина пути из $j$ в $i$ ($dst(j, i)$).</p>

<p>Ответом является минимум по $i$ среди путей, обходящих все вершины:</p>

$$ans = \min\limits_{i \in \mathbb{V}} dp[\mathbb{V}][i]$$

<p>Запись $\mathbb{V}$ обозначает множество всех вершин.</p>

<p>Может показаться, что порядок пересчёта такого ДП будет достаточно сложным.
На самом деле это не так: заметьте что для пересчета $dp[mask][i]$ нам нужно,
чтобы уже был посчитан ответ для маски $mask \backslash i$. Можно легко доказать,
что в численном выражении $mask \backslash i$ будет гарантированно меньше $mask$,
так как на некоторой позиции в $mask$ будет находиться бит $1$, а в
$mask \backslash i$ бит $0$. Значит, можно просто пересчитывать ДП в порядке
возрастания значения $mask$ в численном выражении.</p>

<h3>Реализация решения задачи о коммивояжёре</h3>

<pre class="prettyprint linenums">
#include &lt;bits/stdc++.h&gt;

using namespace std;

const double INF = 1e9 + 7;     //бесконечность

double x[20], y[20];    //координаты городов.

//Заметим, что для N элементов существует 2^N возможных подмножеств (масок)
//значением от 0 до 2^N - 1.
//Можно просто возвести 2 в произвольную степень с помощью битового сдвига:
//2^N = 1 &lt;&lt; N
double dp[1 &lt;&lt; 20][20];

//Расстояние между городами a и b
double dst(int a, int b) {
    double dx = x[a] - x[b], dy = y[a] - y[b];
    return sqrt(dx * dx + dy * dy);
}

int main() {
    int n;
    cin >> n;

    for (int i = 0; i &lt; n; i++) {
        cin >> x[i] >> y[i];
    }

    for (int mask = 0; mask &lt; (1 &lt;&lt; n); mask++) {
        for (int i = 0; i &lt; n; i++) {
            dp[mask][i] = INF;
        }
    }

    for (int i = 0; i &lt; n; i++) {
        dp[1 &lt;&lt; i][i] = 0;    //Маска 1 &lt;&lt; i обозначает множество {i}.
    }

    for (int mask = 2; mask &lt; (1 &lt;&lt; n); mask++) {
        for (int i = 0; i &lt; n; i++) {
            if ((mask >> i) &amp; 1) {      //Если mask содержит i
                int mask_without_i = mask ^ (1 &lt;&lt; i);

                for (int j = 0; j &lt; n; i++) {
                    if (j != i &amp;&amp; ((mask >> j) &amp; 1)) {  //Если j != i и mask содержит j
                        dp[mask][i] = min(dp[mask][i], dp[mask_without_i][j] + dst(j, i));
                    }
                }
            }
        }
    }

    double ans = INF;
    int mask_all = (1 &lt;&lt; n) - 1;  //маска, содержащая все элементы

    for (int i = 0; i &lt; n; i++) {
        ans = min(ans, dp[mask_all][i]);
    }

    cout &lt;&lt; ans &lt;&lt; endl;
}
</pre>

</body>
</html>