<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Обход в ширину (BFS)</title>

    <link rel="stylesheet" type="text/css" href="styles.css">

    <!-- MathJax for embedded LaTeX -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
    </script>
    <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

    <!-- Google code prettify (and a hack for displaying all line numbers). -->
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
    <style>
        .prettyprint ol.linenums > li { list-style-type: decimal; }
    </style>
</head>

<body>

<h1>Обход в ширину (BFS)</h1>

<h3>Определение</h3>

<p>Под обходом понимается последовательное посещение (обработка) вершин графа в
определённом порядке. Одним из двух часто использующихся способов обхода
является обход в ширину, или BFS (<em>англ.</em> breadth-first search, поиск в
ширину). Его иногда также называют волновым, по аналогии с распространяющейся
волной.</p>

<p>Суть BFS достаточно проста. Обход начинается с посещения определённой вершины
(для обхода всего графа часто выбирается произвольная вершина). Затем алгоритм
посещает соседей этой вершины. За ними &ndash; соседей соседей, и так далее.</p>

<p>Более формально, пусть $d[i]$ &ndash; расстояние от начальной вершины до
вершины с номером $i$ (длина кратчайшего пути в рёбрах). BFS посещает вершины
в порядке возрастания $d[i]$: от наименее до наиболее отдалённых.</p>

<img style="display: block; margin: auto; width: 500px" src="resources/Animated_BFS.gif" />

<p>Серым помечены вершины в очереди на посещение, чёрным &ndash; уже посещённые.</p>

<h3>Алгоритм</h3>

<p>Как можно увидеть из иллюстрации, сам алгоритм достаточно тривиален.
Поддерживается очередь из вершин для посещения. При посещении очередной
вершины в очередь добавляются все её соседи, которые ещё не были посещены и
ещё не находятся в очереди. Для проверки, была ли вершина уже посещена,
используется массив меток. Изначально $visited[i] = false$ для всех $i$
кроме начальной вершины. При добавлении вершины $i$ в очередь $visited[i]$
присваивается $true$.</p>

<h3>Реализация</h3>

<p>Реализуем простой BFS для графа заданного списком смежности:</p>

<pre class="prettyprint linenums">
#include &lt;bits/stdc++.h&gt;

using namespace std;

vector&lt;int&gt; graph[100000];
bool used[100000];      //вместо visited массив меток обычно называют used.

int main() {
    //Ввод графа...

    queue&lt;int&gt; q;
    q.push(0);              //в качестве начальной вершины используем 0.
    visited[0] = true;

    while (!q.empty()) {
        int cur = q.top();  //извлекаем из очереди текущую вершину
        q.pop();

        //Здесь должна быть обработка текущей вершины.
        cout &lt;&lt; "BFS at vertex " &lt;&lt; cur + 1 &lt;&lt; endl;

        for (int neighbor: graph[cur]) {    //добавляем всех непосещённых соседей.
            if (!used[neighbor]) {
                q.push(neighbor);
                used[neighbor] = true;
            }
        }
    }
}
</pre>

<h3>Практическое применение: вычисление расстояния до всех вершин</h3>

<p>BFS по определению посещает вершины в порядке возрастания расстояния от них
до начальной. Поэтому одним из главных его применений является вычисление
расстояния от заданной вершины до всех остальных.</p>

<p>Модификация алгоритма, необходимая для этого, минимальна. Пусть при
обработке вершины $i$ мы добавляем в очередь вершину $j$. Это значит, что
кратчайший путь от начальной вершины до вершины $j$ проходит через вершину
$i$.</p>

<p style="display: block; margin: auto; width: 60%; border: 1px solid black; padding: 5px">
Доказательство: допустим, что существует более короткий путь в $j$, не
проходящий через $i$. Обозначим предпоследнюю вершину этого пути $k$.
Так как путь в $j$ через $k$ короче пути в $j$ через $i$ можно сделать вывод,
что расстояние до $k$ меньше расстояния до $i$. Но по определению BFS вершина
$k$ в таком случае была бы уже обработана, а значит, $j$ бы уже находилась
в очереди. Получили противоречие. Следовательно, подходящей вершины $k$ не
существует.
</p>

<p>Обозначим расстояние от начальной вершины до вершины $i$ как $dst[i]$.
В таком случае верно, что $dst[j] = dst[i] + 1$. Таким образом мы можем
рассчитать растояние для всех вершин.</p>

<p>Реализация:</p>

<pre class="prettyprint linenums">
#include &lt;bits/stdc++.h&gt;

using namespace std;

vector&lt;int&gt; graph[100000];
bool used[100000];
int dst[100000];

int main() {
    //Ввод графа...

    for (int i = 0; i &lt; 100000; i++) {   //изначально заполним массив dst значением -1
        dst[i] = -1;                     //оно будет обозначать, что расстояние до этой вершины ещё неизвестно
    }

    queue&lt;int&gt; q;
    q.push(0);
    visited[0] = true;
    dst[0] = 0;         //теперь при добавлении каждой вершины в очередь мы вычисляем расстояние до неё

    while (!q.empty()) {
        int cur = q.top();
        q.pop();

        for (int neighbor: graph[cur]) {
            if (!used[neighbor]) {
                q.push(neighbor);
                used[neighbor] = true;
                dst[neighbor] = dst[cur] + 1;   //вот и весь код расчёта расстояния
            }
        }
    }

    for (int i = 0; i &lt; n; i++) {
        if (dst[i] != -1) {
            cout &lt;&lt; "Distance between vertices 1 and " &lt;&lt; i + 1 &lt;&lt; " is " &lt;&lt; dst[i] &lt;&lt; endl;
        } else {
            cout &lt;&lt; "Vertex " &lt;&lt; i + 1 &lt;&lt; " cannot be reached from vertex 1." &lt;&lt; endl;
        }
    }
}
</pre>

<p>Стоит заметить одно важное свойство. Если существуют вершины, в которые
невозможно добраться из 1-й вершины, $dst[i]$ для них будет равно $-1$. Можно
вспомнить об определении связности графа. Если после окончания работы алгоритма
в массиве $dst$ осталось хоть одно значение $-1$, то граф не является связным.
Таким образом BFS можно также использовать для проверки на связность.</p>

<h3>BFS с сохранением пути</h3>

<p>Иногда кроме длины кратчайшего пути в задаче требуется также вывести вершины,
через которые он проходит. BFS легко модифицируется для решения этой задачи.</p>

<p>Пусть при обработке вершины $i$ мы добавляем в очередь вершину $j$. Это
значит, что кратчайший путь от начальной вершины до вершины $j$ проходит через
вершину $i$ (доказательство выше). Значит последним ребром в кратчайшем пути
до $j$ будет ребро $i - j$, а весь остальной путь будет совпадать с кратчайшим
путём до $i$. Просто сохраним тот факт, что предыдущей вершиной для $j$
является $i$. Для этого будем использовать массив $prev$. Простой пометки
$prev[j] = i$ хватит для восстановления пути после завершения работы алгоритма.</p>

<p>Реализация:</p>

<pre class="prettyprint linenums">
#include &lt;bits/stdc++.h&gt;

using namespace std;

vector&lt;int&gt; graph[100000];
bool used[100000];
int dst[100000];
int prev[100000];

int main() {
    //Ввод графа...

    for (int i = 0; i &lt; 100000; i++) {
        dst[i] = -1;
    }

    queue&lt;int&gt; q;
    q.push(0);
    visited[0] = true;
    dst[0] = 0;
    prev[0] = -1;   //Пометка, означающая, что у вершины 0 нет предыдущей.

    while (!q.empty()) {
        int cur = q.top();
        q.pop();

        for (int neighbor: graph[cur]) {
            if (!used[neighbor]) {
                q.push(neighbor);
                used[neighbor] = true;
                dst[neighbor] = dst[cur] + 1;
                prev[neighbor] = cur;   //сохранение предыдущей вершины
            }
        }
    }

    //Восстановим кратчайший путь до вершины k (которую, предполагается, мы уже ввели)
    //Для восстановления пути пройдём его в обратном порядке, начиная с j, и развернём.

    vector&lt;int&gt; path;

    int cur = k;         //текущая вершина пути
    path.push_back(cur);

    while (prev[cur] != -1) {   //пока существует предыдущая вершина
        cur = prev[cur];        //переходим в неё
        path.push_back(cur);    //и дописываем к пути
    }

    reverse(path.begin(), path.end());

    cout &lt;&lt; "Shortest path between vertices 1 and " &lt;&lt; k + 1 &lt;&lt; " is: " &lt;&lt; endl;

    for (int v: path) {
        cout &lt;&lt; v + 1 &lt;&lt; ", ";
    }
}
</pre>

<h3>Применение BFS без явных графов</h3>

<p>Кроме собственно графов, BFS часто используется для поиска путей в
прямоугольном поле, состоящем из клеток. В этом поле находится некоторая
"фигура" которая может перемещаться согласно определённым условиям. На самом
деле, такое поле задаёт граф, вершины которого &ndash; клетки поля, а ребро
из одной клетки в другую существует, если фигура может совершить соответствующее
перемещение.</p>

<p>Такие задачи можно решать без явного построения списка смежности, работая
только с самой матрицей. В качестве примера приведём решение следующей задачи:</p>

<p style="display: block; margin: auto; width: 60%">
На шахматной доске размером $N * N$ ($1 \le N \le 1000$) в клетке $(x_1, y_1)$
находится конь. Определить, за сколько ходов он может попасть в клетку $(x_2, y_2)$.
</p>

<p>На всякий случай напомним, что конь может ходить "буквой Г" в любом
направлении. Математически это значит, что конь может изменить одну из своих
координат на $2$ или $-2$, а другую на $1$ или $-1$. Это даёт нам следующий
набор векторов, задающий ходы коня:</p>

$$(1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1)$$

<p>Решение:</p>

<pre class="prettyprint linenums">
#include &lt;bits/stdc++.h&gt;

using namespace std;

int n;
bool used[1000][1000];
int dst[1000][1000];

//Вспомогательная функция для проверки, можем ли мы пойти в заданную клетку.
bool not_visited(int x, int y) {
    return x >= 0 &amp;&amp; x &lt; n
        &amp;&amp; y >= 0 &amp;&amp; y &lt; n
        &amp;&amp; !used[x][y];
}

int main() {
    int x1, y1, x2, y2;
    cin >> n >> x1 >> y1 >> x2 >> y2;   //n объявлена глобально

    x1--, y1--, x2--, y2--;     //не забываем про сдвиг координат.

    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            dst[i][j] = -1;
        }
    }

    queue&lt;pair&lt;int, int&gt;&gt; q;    //Мы храним уже не номера вершин, а координаты клеток.
    q.push({x1, y1});       //Предполагается использование С++11, в противном случае используйте make_pair  
    used[x1][y1] = true;
    dst[x1][y1] = 0;

    while (!q.empty) {
        pair&lt;int, int&gt; cur = q.top();
        q.pop();

        int cx = cur.first, cy = cur.second;

        //Я очень надеюсь, что в будущем это можно будет делать более адекватным способом (2015).
        if (not_visited(cx + 1, cy + 2)) {
            q.push({cx + 1, cy + 2});
            used[cx + 1][cy + 2] = true;
            dst[cx + 1][cy + 2] = dst[cx][cy] + 1;
        }

        if (not_visited(cx + 1, cy - 2)) {
            q.push({cx + 1, cy - 2});
            used[cx + 1][cy - 2] = true;
            dst[cx + 1][cy - 2] = dst[cx][cy] + 1;
        }

        if (not_visited(cx - 1, cy + 2)) {
            q.push({cx - 1, cy + 2});
            used[cx - 1][cy + 2] = true;
            dst[cx - 1][cy + 2] = dst[cx][cy] + 1;
        }

        if (not_visited(cx - 1, cy - 2)) {
            q.push({cx - 1, cy - 2});
            used[cx - 1][cy - 2] = true;
            dst[cx - 1][cy - 2] = dst[cx][cy] + 1;
        }

        if (not_visited(cx + 2, cy + 1)) {
            q.push({cx + 2, cy + 1});
            used[cx + 2][cy + 1] = true;
            dst[cx + 2][cy + 1] = dst[cx][cy] + 1;
        }

        if (not_visited(cx + 2, cy - 1)) {
            q.push({cx + 2, cy - 1});
            used[cx + 2][cy - 1] = true;
            dst[cx + 2][cy - 1] = dst[cx][cy] + 1;
        }

        if (not_visited(cx - 2, cy + 1)) {
            q.push({cx - 2, cy + 1});
            used[cx - 2][cy + 1] = true;
            dst[cx - 2][cy + 1] = dst[cx][cy] + 1;
        }

        if (not_visited(cx - 2, cy - 1)) {
            q.push({cx - 2, cy - 1});
            used[cx - 2][cy - 1] = true;
            dst[cx - 2][cy - 1] = dst[cx][cy] + 1;
        }
    }

    if (dst[x2][y2] != -1) {
        cout &lt;&lt; dst[x2][y2];
    } else {
        cout &lt;&lt; "Impossible";
    }
}
</pre>

<p>Как видите, отличие заключается лишь в том, что вместо перебора соседних вершин
из списка смежности, мы вычисляем их на лету используя возможные ходы фигуры.</p>

</body>
</html>