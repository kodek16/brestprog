<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Основные элементы комбинаторики</title>

    <link rel="stylesheet" type="text/css" href="styles.css">

    <!-- MathJax for embedded LaTeX -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
    </script>
    <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

    <!-- Google code prettify (and a hack for displaying all line numbers). -->
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
    <style>
        .prettyprint ol.linenums > li { list-style-type: decimal; }
    </style>
</head>

<body>

<h1>Основные элементы комбинаторики</h1>

<h3>Комбинаторика</h3>

<p>Комбинаторика, как можно судить по названию, &ndash; раздел математики,
изучающий различные комбинации объектов и множеств. Комбинаторика очень
тесно связана с информатикой, и часто встречается в олимпиадных задачах.
Она включает в себя множество понятий, но в программировании чаще всего
используются две из них:</p>

<h3>Перестановки</h3>

<p>Когда две последовательности состоят из одинаковых объектов, расположенных
в разном порядке, они называются <strong>перестановками</strong> одной и той же
последовательности. Например, для последовательности $1, 2, 3$ существует
6 перестановок:</p>

<ul>
    <li>$1, 2, 3$</li>
    <li>$1, 3, 2$</li>
    <li>$2, 1, 3$</li>
    <li>$2, 3, 1$</li>
    <li>$3, 1, 2$</li>
    <li>$3, 2, 1$</li>
</ul>

<p>Рассчитать число существующих перестановок достаточно просто. На первое
место может стать один из $N$ элементов. На второе место &ndash; один из
$N - 1$ оставшихся. На третье $N - 2$, и так далее. На последнее место
может стать только один элемент, нигде до этого не использовавшийся. Значит,
количество перестановок последовательности длиной $N$ равно</p>

$$P_N = 1 * 2 * \ldots * N = \prod\limits_{i = 1}^N i = N!$$

<p>Факториал, по определению, и является количеством перестановок
последовательности длиной $N$.</p>

<p>Более интересная алгоритмически задача: вывести все перестановки заданной
последовательности. Наивный алгоритм её решения является достаточно эффективным,
и является отличным примером распространённого подхода <strong>рекурсивного
перебора</strong>.</p>

<p>Суть алгоритма проста. Обозначим изначальную последовательность $a$.
Определим рекурсивную функцию $f(i_1, i_2, \ldots, i_k)$. Вызов этой
функции должен вывести все перестановки последовательности $a$, начинающиеся
с чисел $a[i_1], a[i_2], \ldots, a[i_k]$.</p>

<p>Крайний случай рекурсии очевиден: если $k = N$, то $a[i_1], a[i_2], \ldots, a[i_k]$
и есть одна из перестановок. Просто выведем её. Во всех других случаях поступаем
следующим образом: пусть $j_1, j_2, \ldots, j_{N - k}$ &ndash; ещё не использованные
индексы. По очереди рекурсивно вызовем $f(i_1, i_2, \ldots, i_k, j_1)$,
$f(i_1, i_2, \ldots, i_k, j_2)$, $\ldots$, $f(i_1, i_2, \ldots, i_k, j_{N - k})$.
Таким образом мы гарантированно переберём все возможные перестановки.</p>

<p>На практике передача в функцию такого большого числа аргументов &ndash;
плохая идея, поэтому функция реализуется по-другому. Просто будем поддерживать
глобальный вектор $v$, в который по мере углубления рекурсии будем добавлять
элементы текущей перестановки. Кроме него также будем поддерживать глобальный
массив $used$: если при вызове функции f для какого-либо $i$ выполняется
условие $used[i]$, это значит, что индекс $i$ уже был использован.</p>

<p>Реализация на C++:</p>

<pre class="prettyprint linenums">
#include &lt;bits/stdc++.h&gt;

using namespace std;

int n;
int a[100000];

bool used[100000];
vector&lt;int&gt; v;

void f(int k) {     //k - количество уже использованных индексов
    if (k == n) {
        cout &lt;&lt; "Permutation: ";
        for (int i: v) {
            cout &lt;&lt; i &lt;&lt; ", ";
        }
        cout &lt;&lt; endl;

        return;
    }

    for (int i = 0; i &lt; n; i++) {
        if (!used[i]) {
            used[i] = true;     //Добавляем в текущую перестановку элемент a[i]
            v.push_back(i);
            f(k + 1);           //Рекурсивно перебираем все перестановки, продолжающиеся a[i]
            v.pop_back();
            used[i] = false;    //Убираем из текущей перестановки элемент a[i]
        }
    }
}

int main() {
    cin >> n;

    for (int i = 0; i &lt; n; i++) {
        a[i] = i + 1;
    }

    f(0);
}
</pre>

<p>Сложность этого алгоритма порядка $O(N! * N^2)$, он будет укладываться в
ограничение по времени при $N \le 10$.</p>

<p>Стоит отметить, что этот алгоритм выводит перестановки в <strong>
лексикографическом порядке</strong>. Так же, как расположены слова
в словаре.</p>

<p>Приём рекурсивного перебора, использующийся в этом алгоритме, очень часто
может добавить вам 15-20 баллов по задаче, по которой иначе вы бы получили
0 (речь идёт о белорусской системе оценки, где каждый тест оценивается
индивидуально). Внимательно изучите его и поэкспериментируйте с ним.</p>

<p>Впрочем стандартная библиотека C++ содержит функции, позволяющие вам
перебирать перестановки последовательности в лексикографическом порядке
без написания своего кода:</p>

<pre class="prettyprint lang-c">
//Преобразует перестановку в следующую лексикографически
//Если перестановка уже является максимальной, возвращает false
bool next_permutation(iterator begin, iterator end);

//Преобразует перестановку в предыдущую лексикографически
//Если перестановка уже является минимальной, возвращает false
bool prev_permutation(iterator begin, iterator end);
</pre>

<h3>Сочетания</h3>

<p><strong>Сочетанием</strong> из $n$ по $k$ называется любой набор из $n$
элементов, выбранных из данных $k$ элементов. Например, рассмотрим множество
$1, 2, 3, 4$. Существует 6 сочетаний по 2 из этого множества:</p>

<ul>
    <li>$1, 2$</li>
    <li>$1, 3$</li>
    <li>$1, 4$</li>
    <li>$2, 3$</li>
    <li>$2, 4$</li>
    <li>$3, 4$</li>
</ul>

<p>Число возможных сочетаний из $n$ по $k$ обозначается $C_n^k$ и вычисляется
по формуле</p>

$$C_n^k = {n! \over k! * (n - k)!}$$

<p>Число сочетаний очень часто встречается в задачах по программированию. Существуют
два способа его вычисления:</p>

<ul>
    <li>
        <p>Наивный</p>
        
        <p>Используется в случаях, когда нужно посчитать небольшое количество $C_n^k$
        за $O(N)$ каждое. Реализация на C++:</p>

        <pre class="prettyprint linenums">
long long fact(int x) {
    long long result = 1;
    for (int i = 2; i &lt;= x; i++) {
        result *= i;
    }

    return result;
}

long long combinations(int n, int k) {
    return fact(n) / fact(k) / fact(n - k);
}
        </pre>

        Разумеется, область применения такого подхода сильно ограничена вместимостью
        типа <code>long long</code>.
    </li>

    <li>
        <p>ДП</p>

        <p>Выразим $C_n^k$ рекурсивно. Рассмотрим последний ($n$-ый) элемент: все сочетания
        можно разделить на две группы: те которые включают его, и те которые не включают.
        Заметим, что все сочетания первой группы содержат $k - 1$ элементов из первых
        $n - 1$, а все сочетания второй группы: $k$ из первых $n - 1$. Значит,</p>

        $$C_n^k = C_{n - 1}^k + C_{n - 1}^{k - 1}$$

        <p>Таким образом мы можем рассчитать значения $C_n^k$ для всех $n \le N$ и $k \le K$
        за $O(NK)$.</p>

        <p>Реализация на С++ (значения в поле по модулю $10^9 + 7$):</p>

        <pre class="prettyprint linenums">
#include &lt;bits/stdc++.h&gt;

using namespace std;

const long long MOD = 1e9 + 7;

long long c[1001][1001];

int main() {
    c[1][1] = 1;
    for (int n = 2; n &lt;= 1000; n++) {
        c[n][1] = n;
        for (int k = 2; k &lt;= n; k++) {
            c[n][k] = (c[n - 1][k] + c[n - 1][k - 1]) % MOD;
        }
    }

    //Можем использовать c...
}
        </pre>
    </li>
</ul>

</body>
</html>