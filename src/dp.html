<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Динамическое программирование на примерах</title>

    <link rel="stylesheet" type="text/css" href="styles.css">

    <!-- MathJax for embedded LaTeX -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
    </script>
    <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

    <!-- Google code prettify (and a hack for displaying all line numbers). -->
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
    <style>
        .prettyprint ol.linenums > li { list-style-type: decimal; }
    </style>
</head>

<body>

<h1>Динамическое программирование на примерах</h1>

<h3>Определение</h3>

<p>Динамическое программирование &ndash; очень широкое понятие, под которое
подходит множество алгоритмов, которым посвящены отдельные лекции. Формально,
динамическое программирование &ndash; способ решения задач с помощью разбиения
их на подзадачи и комбинирования ответов на них. Впрочем, для абсолютного
большинства людей, не сталкивавшихся раньше с ДП, это определение ничего не
объясняет. Попробуем изменить его так, чтобы оно стало немного
понятнее, но всё ещё подходило под большинство примеров из олимпиадного
программирования:</p>

<p><strong>Динамическое программирование &ndash; способ решения задачи с помощью
выражения ответа в виде функции от ответов на ту же задачу для других входных данных.
</strong></p>

<p>Скорее всего, всё ещё непонятно. Гораздо эффективнее будет привести несколько
примеров, начиная с самого элементарного.</p>

<h3>Связь между ДП и рекурсией. Последовательность Фибоначчи</h3>

<p>Если вы всё же что-то вынесли из приведённого выше определения, то могли
заметить, насколько оно похоже на определение рекурсивной функции. На самом
деле, ДП &ndash; это "всего лишь" способ решения задач на рекурсивные
последовательности с сохранением ответа.</p>

<p>Вспомним реализацию расчёта $n$-го числа Фибоначчи из лекции про рекурсию:</p>

<pre class="prettyprint linenums">
int fib(int n) {
    if (n &lt; 2) {
        return 1;
    } else {
        return fib(n - 1) + fib(n - 2);
    }
}
</pre>

<p>Мы отмечали, что она не подходит для использования на практике из-за слишком
высокой сложности. Откуда же берётся эта сложность? Просто рассмотрим дерево вызовов
функции $fib$ для $n = 6$:

<img style="display: block; margin: auto" src="resources/fib_callgraph.png" />

<p>Как видите, для подсчёта $fib(6)$ функцию $fib$ пришлось вызвать 15 раз, хотя
логично, что хватило бы шести. Вся проблема заключается в том, что для некоторых
$x$ функция $fib(x)$ будет вызываться больше одного раза, и каждый раз высчитываться
рекурсивно заново. Очевидно, что для оптимальной работы значения функции нужно
сохранять для последующего использования. ДП &ndash; один из способов такой
оптимизации.</p>

<p>Приведём решение задачи о последовательности Фибоначчи с помощью ДП:</p>

<pre class="prettyprint linenums">
#include &lt;bits/stdc++.h&gt;

using namespace std;

int fib[100001];

int main() {
    int n;      //N &lt;= 100000
    cin >> n;

    fib[1] = fib[2] = 1;    //начальные значения

    for (int i = 3; i &lt; N; i++) {
        fib[i] = fib[i - 1] + fib[i - 2];   //формула перехода
    }

    cout &lt;&lt; fib[n];   //вычисление ответа
}
</pre>

<p>Идея проста: для вычисления $fib(n)$ нам нужны значения $fib(n - 1)$ и
$fib(n - 2)$. Давайте просто считать $fib$ в порядке возрастания $n$, сохраняя
результаты в массив.</p>

<p>В большинстве случаев ДП характеризуется тремя главными параметрами:</p>

<ul>
    <li><strong>Начальные значения.</strong> Аналогично крайним случаям в рекурсивных функциях.</li>
    <li><strong>Формула перехода.</strong> Описывает рекурсивную зависимость.</li>
    <li><strong>Вычисление ответа.</strong> В некоторых случаях ответ может быть не последним значением,
        а суммой или максимумом по значениям.</li>
</ul>

<h3>Путь в матрице</h3>

<p>Задачи на поиск оптимального пути в матрице, наверное, самые классические,
после задач на последовательность Фибоначчи. В таких задачах каждой клетке
в матрице присвоено некоторое число, и нужно найти путь между двумя клетками
с максимальной или минимальной суммой.</p>

<img style="display: block; margin: auto" src="resources/matrix_maxpath.png" />

<p>Приведём решение такой задачи. Будем искать путь между левой верхней
и правой нижней клетками с максимальной суммой, если ходить можно только
вниз или вправо. Для решения задачи используем следующее ДП: $dp[i][j]$ &ndash;
максимальная сумма, которую мы можем набрать, дойдя до клетки $(i, j)$.
Опишем ДП:</p>

<ul>
    <li>Начальные значения: $dp[0][0] = c[0][0]$ ($c$ &ndash; исходная матрица). <br />
    Мы находимся в клетке $(0, 0)$, значит мы ещё не двигались, то есть
    собранная нами сумма равна значению в этой клетке.</li>

    <li>Формула перехода: $dp[i][j] = \max(dp[i - 1][j], dp[i][j - 1]) + c[i][j]$ <br />
    Мы можем перейти в клетку $(i, j)$ либо сверху, либо слева. Выгоднее перейти из
    той, в которую мы до этого пришли с большей суммой.</li>

    <li>Ответ: $dp[n - 1][m - 1]$.</li>
</ul>

<p>Реализация на C++:</p>

<pre class="prettyprint linenums">
#include &lt;bits/stdc++.h&gt;

using namespace std;

int c[1000][1000];
int dp[1000][1000];

int main() {
    int n, m;
    cin >> n >> m;

    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            cin >> c[i][j];
        }
    }

    dp[0][0] = 0;

    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (i || j) {   //цикл не должен заходить в клетку (0, 0)
                dp[i][j] = INT_MIN;     //код рассчёта максимума получился
                                        //достаточно длинным из-за дополнительных
                                        //проверок на выход за границы матрицы

                if (i - 1 >= 0) {
                    dp[i][j] = max(dp[i][j], dp[i - 1][j] + c[i][j]);
                }

                if (j - 1 >= 0) {
                    dp[i][j] = max(dp[i][j], dp[i][j - 1] + c[i][j]);
                }
            }
        }
    }

    cout &lt;&lt; dp[n - 1][m - 1];
}
</pre>

<p>При реализации ДП всегда нужно быть уверенным, что все значения, необходимые
для вычисления текущего, уже были вычислены.</p>

<h3>Наибольшая возрастающая подпоследовательность</h3>

<p>Ещё одна классическая задача на ДП. Её формулировка следующая: задана
последовательность из N чисел. Нужно удалить из неё минимальное число
элементов, чтобы оставшиеся составляли строго (в других версиях &ndash; нестрого)
возрастающую последовательность.</p>

<p>Например, рассмотрим последовательность $6, 2, 5, 4, 2, 5, 6$. Мы можем
вычеркнуть из неё три числа (первая $6$, первая $5$ и вторая $2$) и получить
возрастающую последовательность $2, 4, 5, 6$, длина которой $4$. Она является
оптимальной, нельзя получить возрастающую подпоследовательность большей длины.</p>

<img style="display: block; margin: auto" src="resources/lis.png" />

<p>Для решения задачи будем использовать ДП следующего вида: $dp[i]$ &ndash;
длина наибольшей возрастающей подпоследовательности, оканчивающейся числом
$a[i]$. Опишем это ДП:</p>

<ul>
    <li>Начальные значения: отсутствуют. <br />
    Достаточно редкий случай, когда формула перехода позволяет решать ДП без
    начальных значений.</li>

    <li>Формула перехода:
    $$\begin{equation} dp[i] = \max(1, \max_{\substack{0 \le j &lt; i \\ a[j] &lt; a[i]}} dp[j] + 1) \end{equation}$$
    Это же по-человечески: мы можем либо начать новую последовательность длиной $1$, либо продолжить любую из уже
    начатых, последний элемент которого строго меньше текущего. Из всех таких последовательностей выгодно выбрать,
    разумеется, самую длинную (это записано во втором аргументе $\max$).
    </li>

    <li>Ответ: $\max\limits_{i} dp[i]$.
    Последовательность не обязательно должна заканчиваться последним элементом.</li>
</ul>

<p>Возможно, реализация будет немного понятнее:</p>

<pre class="prettyprint linenums">
#include &lt;bits/stdc++.h&gt;

using namespace std;

int a[100000];
int dp[100000];

int main() {
    int n;
    cin >> n;

    for (int i = 0; i &lt; n; i++) {
        cin >> a[i];
    }

    for (int i = 0; i &lt; n; i++) {
        dp[i] = 1;      //Мы можем начать новую подпоследовательность

        for (int j = 0; j &lt; i; j++) {
            if (a[j] &lt; a[i]) {
                dp[i] = max(dp[i], dp[j] + 1);      //Или продолжить уже начатую.
            }
        }
    }

    int ans = max_element(dp, dp + n);      //C++11
    cout &lt;&lt; ans;
}
</pre>

<p>Как можно заметить, сложность такого решения $O(N^2)$. Существует другое
решение этой задачи, не такое тривиальное, имеющее имеет сложность $O(N \log N)$.
Его можно охарактеризовать как ДП (с натяжкой), но оно значительно отличается от
примеров выше. Разберём его.</p>

<p>Будем идти по последовательности слева направо, поддерживая массив $d$, где
$d[i]$ &ndash; минимальный последний элемент среди всех возможных
возрастающих подпоследовательностей длиной $i$. Если таковых не существует,
то примем $d[i] = \infty$. Можно достаточно тривиально доказать, что массив
$d$ будет строго возрастающим:</p>

<div style="display: block; margin: auto; width: 60%">
    <p>По определению d[i] &ndash; <em>минимальный</em> последний элемент среди
    <em>всех</em> подпоследовательностей длиной $i$. Значит, $i$-ый элемент
    любой подпоследовательности длиной больше $i$ не меньше, чем $d[i]$.
    Следовательно, не может существовать строго возрастающей подпоследовательности
    длиной $i + 1$, такой что её последний элемент меньше либо равен $d[i]$,
    что и требовалось доказать.</p>
</div>

<p> Пусть мы обрабатываем очередной элемент $a[i]$, и хотим с его помощью
продлить некоторые последовательности. С помощью бинарного поиска найдём
в массиве $d$ первый такой индекс $j$, что $a[i] &lt; d[j]$. Утверждается,
что элемент $a[j]$. может эффективно продолжить только последовательность
длиной $j - 1$. Доказательство:</p>

<div style="display: block; margin: auto; width: 60%">
    <p>$a[i] &lt; d[j]$ по определению, а массив $b$ строго возрастает. Чтобы
    продлить некоторую последовательность, $a[i]$ должен быть строго больше
    её последнего элемента. Значит, $a[i]$ не может продлить ни одну
    последовательность длиной $\ge j$.</p>

    <p>Чтобы эффективно продлить последовательность длиной $k$ должно
    выполняться условие $a[i] &lt; d[k + 1]$. Но $a[i]$ по определению
    больше либо равен $d[j - 1]$, а значит и всем предыдущим значениям. Значит,
    $a[i]$ не может продлить ни одну последовательность длиной $&lt; j - 1$</p>

    <p>Следовательно, если $a[i]$ может эффективно продлить какую-либо
    последовательность, то её длина равна $j - 1$.</p>
</div>

<p>Реализация на C++:</p>

<pre class="prettyprint linenums">
#include &lt;bits/stdc++.h&gt;

using namespace std;

const int INF = 1000000007;     //"бесконечность"

int a[100000];
int d[100001];

int main() {
    int n;
    cin >> n;

    for (int i = 0; i &lt; n; i++) {
        cin >> a[i];
    }

    for (int i = 2; i &lt; n; i++) {
        d[i] = INF;
    }

    d[1] = a[0];    //В качестве начального значения, обработаем первый элемент,
                    //и запишем его как минимальный для длины 1.

    for (int i = 1; i &lt; n; i++) {
        int j = upper_bound(d + 1, d + n + 1, a[i]) - d;   //не забываем сдвинуть индексы.

        if (j == 1 || a[i] > d[j - 1]) {    //если a[i] строго больше предыдущего элемента, а не равен ему
            d[j] = min(d[j], a[i]);         //попытаемся с его помощью улучшить ответ для длины j
        }
    }

    for (int i = n; i > 0; i--) {   //выводим максимальное i, для которого d[i] не равно бесконечности.
        if (d[i] != INF) {
            cout &lt;&lt; i;
            break;
        }
    }
}
</pre>

<p>У вас мог возникнуть вопрос: где в этом решении ДП? На самом деле, $d$, хоть
и неявно, является рекурсивной функцией, так как $d[i]$ зависит от $d[i - 1]$.
Её отличие от нормальных рекурсивных функций заключается в нетрадиционном <strong>
порядке пересчёта</strong> &ndash; переборе $a[i]$ c обновлением промежуточных
значений $d[j]$, вместо традиционного перебора $dp[i]$.</p>

<p>Собственно, этот алгоритм &ndash; плохой пример ДП. Он приведён только
для решения задачи за $O(N \log N)$. Даже у опытных программистов могут возникать
серьёзные сомнения, причислять ли его к классу ДП.</p>

<p>У этой задачи есть ещё одно решение сложностью $O(N \log N)$, которое может
показаться проще. Оно разбирается в лекции про дерево Фенвика.</p>

<h3>ДП на дереве</h3>

<!-- Да, это лекция для начинающих -->

<p>В качестве последнего примера в этой лекции используем ещё одну часто
используемую разновидность ДП &ndash; ДП на дереве. Суть алгоритмов от этого
не меняется: вместо значения рекурсивной функции для клетки матрицы
используется её значение для вершины дерева, которое выражается через
значения от других вершин (чаще всего дочерних).</p>

<p>Для реализации ДП на дереве чаще всего используется "настоящая" рекурсия:
DFS, поэтому она значительно отличается от классического ДП на массивах.</p>

<p>Давайте решим следующую задачу: каждой вершине дерева присвоено
некоторое число (возможно отрицательное). Нужно найти в дереве путь с
максимальной суммой вершин (начальные и конечные вершины могут быть произвольными).</p>

<img style="display: block; margin: auto" src="resources/tree_maxpath.png" />

<p>ДП будет выглядеть так: $dp[v]$ &ndash; сумма наилучшего пути, начинающегося
в вершине $v$, и спускающего вниз по поддереву. <br />
Кроме этого будем считать параметр $ans[v]$, в котором будем хранить ответ
для поддерева вершины $v$, то есть, сумму наилучшего пути, полностью содержащегося
в поддереве $v$.</p>

<ul>
    <li>Начальные значения: $dp[v] = ans[v] = c[v]$, для всех листьев $v$ ($c$ &ndash; значения вершин). <br />
    Единственный путь в поддереве листа (которое состоит только из него самого) &ndash; путь,
    включающий в себя только лист. Его и запишем в оба массива.</li>

    <li>Формулы перехода:
        $$dp[v] = \max(c[v], \max\limits_{v \rightarrow u} dp[u] + c[v]) \\
        ans[v] = \max(dp[v], \max\limits_{v \rightarrow u} ans[u], \max_{\substack{v \rightarrow u, w \\ u \ne w}} (dp[u] + dp[w]) + c[v])$$
        
        <p>Рассмотрим эти формулы. $dp[v]$ пересчитывается просто: среди всех дочерних
        вершин выбираем ту, у которой набольшее значение $dp[u]$, и продолжаем этот
        путь до вершины $v$. Если это нам невыгодно (сумма у всех путей отрицательная),
        начинаем новый путь, состоящий только из вершины $v$.</p>

        <p>$ans[v]$ пересчитывается немного сложнее. У нас есть три варианта:</p>
        <ul>
            <li>Наилучший путь в поддереве $v$ заканчивается в вершине $v$: используем значение $dp[v]$</li>
            <li>Наилучший путь в поддереве $v$ не проходит через вершину $v$ (а значит, полностью содержится в
            поддереве одной из дочерних вершин): используем максимальное значение $ans[u]$, где $u$ &ndash;
            дочерние вершины $v$</li>
            <li>Наилучший путь в поддереве $v$ проходит через вершину $v$ (а значит, начинается в поддереве
            одной из дочерних вершин и заканчивается в поддереве другой): выбираем две дочерние вершины
            $u, w$ с максимальными значениями $dp[u], dp[w]$ и соединяем эти пути через вершину $v$.</li>
        </ul>

        <p>Эти три варианта и отображены в формуле.</p>
    </li>

    <li>Ответ: $ans[r]$, $r$ - корень дерева.</li>
</ul>

<p>Реализация на C++:</p>

<pre class="prettyprint linenums">
#include &lt;bits/stdc++.h&gt;

using namespace std;

vector&lt;int&gt; tree[100000];
int c[100000];  //массив со значениями вершин

int dp[100000];
int ans[100000];

void dfs(int v, int p = -1) {
    for (int u: graph[v]) {     //сначала считаем ДП для всех дочерних вершин
        dfs(u, v);
    }

    //Считаем dp[v]
    dp[v] = c[v];
    for (int u: graph[v]) {
        if (u != p) {
            dp[v] = max(dp[v], dp[u] + c[v]);
        }
    }

    //Считаем ans[v]: вариант 1
    ans[v] = dp[v];

    //Считаем ans[v]: вариант 2
    for (int u: graph[v]) {
        if (u != p) {
            ans[v] = max(ans[v], ans[u]);
        }
    }

    //Считаем ans[v]: вариант 3
    if (graph[v].size() >= 3) {     //как минимум две дочерних вершины (не считая родительскую)
        int f_max = INT_MIN, s_max = INT_MIN;   //первый и второй максимумы
        for (int u: graph[v]) {
            if (u != p) {
                if (dp[u] >= f_max) {
                    s_max = f_max;
                    f_max = dp[u];
                } else if (dp[u] > s_max) {
                    s_max = dp[u];
                }
            }
        }

        ans[v] = max(ans[v], f_max + s_max + c[v]);
    }
}

int main() {
    //Ввод дерева и массива c...

    dfs(0);

    cout &lt;&lt; ans[0];
}
</pre>

<p>Если эта задача показалась вам слишком сложной, не расстраивайтесь. Она
приведена в этой лекции в качестве "бонусного" материала. Вернитесь к этой
теме через пару месяцев.</p>

</body>
</html>