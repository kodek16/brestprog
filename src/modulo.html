<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Операции по модулю</title>

    <link rel="stylesheet" type="text/css" href="styles.css">

    <!-- MathJax for embedded LaTeX -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
    </script>
    <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

    <!-- Google code prettify (and a hack for displaying all line numbers). -->
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
    <style>
        .prettyprint ol.linenums > li { list-style-type: decimal; }
    </style>
</head>

<body>

<h1>Операции по модулю</h1>

<h3>Математические термины</h3>

<p>Во всём последующем материале никак не фигурирует понятие "модуль числа"
в привычном смысле ($\lvert x \rvert$). Речь идёт о "сравнении по модулю".
Если вы не знакомы с этим понятием, вкратце сравнение по модулю выглядит
следующим образом:</p>

$$a \equiv b \pmod{m}.$$

<p>Это читается "$a$ сравнимо с $b$ по модулю $m$", и в привычных для
информатики терминах обозначает следующее:</p>

$$(a - b) \bmod m = 0$$

<p>или</p>

$$a \bmod m = b \bmod m,$$

<p>где $\bmod$ &ndash; операция взятия остатка от деления.</p>

<h3>Поле по модулю</h3>

<p>В некоторых задачах фигурирует условие следующего вида: "выведите остаток от
деления ответа на 1000000007" или "выведите ответ по модулю 1000000007". Это
вовсе не значит, что вам нужно посчитать ответ обычным способом и вывести 
<code class="prettyprint">ans % 1000000007</code>. Ответ в таких задачах
часто настолько огромен, что его сложно представить даже с помощью длинной
арифметики. Для их решения нужно вносить изменения во все
промежуточные вычисления, чтобы не выйти за границы целочисленного типа.</p>

<p>Можно сказать, что в таких задачах мы оперируем не <em>числами</em>, а
их <em>остатками от деления</em> на 1000000007. Это возможно благодаря
следующим свойствам вычислений с остатком:</p>

$$(a + b) \bmod m = ((a \bmod m) + (b \bmod m)) \bmod m \\
(a - b) \bmod m = ((a \bmod m) - (b \bmod m)) \bmod m \\
(ab) \bmod m = ((a \bmod m) * (b \bmod m)) \bmod m$$

<p>Таким образом, мы можем выполнять три важнейшие математические операции,
даже не зная точных значений чисел, только их остатки от деления на заданное
число (<em>модуль</em>). Деление &ndash; отдельная тема,
которую мы обсудим позже.</p>

<p>Не углубляясь в определения терминов из высшей математики, операции с остатками
от деления на модуль называются операциями в <em>поле по модулю</em>, а сами
остатки &ndash; <em>числами по модулю</em>.</p>

<p><em>Примечание: термин "поле" применим только в том случае, когда модуль
&ndash; простое число. В противном случае это называется "кольцо". Отличие
заключается в том, что для поля определена операция деления, а для кольца
&ndash; нет.</em></p>

<h3>Доказательство возможности сложения, вычитания и умножения по модулю</h3>

<p>Для начала докажем достаточно очевидное утверждение:</p>

$$\forall n \in \mathbb{Z}: x \bmod m = (x + nm) \bmod m.$$

<p>Доказательство:</p>

$$((x + nm) - x) \bmod m = nm \bmod m = 0$$

<p>Значит, по определению сравнимости, $\forall n \in \mathbb{Z}: x \equiv x + nm \pmod{m}$,
что и требовалось доказать.</p>

<p>Докажем возможность сложения ($x$ и $y$ &ndash; целые части от
деления $a$ и $b$ на $m$ соответственно):</p>

$$(a + b) \bmod m = \\
= (xm + a \bmod m + ym + b \bmod m) \bmod m = \\
= (a \bmod m + b \bmod m + m(x + y)) \bmod m, = \\
= (a \bmod m + b \bmod m) \bmod m,$$

<p>что и требовалось доказать.</p>

<p>Вычитание и умножение доказываются похожим образом:</p>

$$(a - b) \bmod m = \\
= (xm + a \bmod m - ym - b \bmod m) \bmod m = \\
= (a \bmod m - b \bmod m + m(x - y)) \bmod m, = \\
= (a \bmod m - b \bmod m) \bmod m,$$

$$(a * b) \bmod m = \\
= ((xm + a \bmod m) * (ym + b \bmod m)) \bmod m = \\
= (a \bmod m * b \bmod m + a \bmod m * ym + b \bmod m * xm + xym^2) \bmod m = \\
= (a \bmod m * b \bmod m + m(a \bmod m * y + b \bmod m * x + xym)) \bmod m = \\
= (a \bmod m * b \bmod m) \bmod m$$

<h3>Пример: вычисление факториала по модулю</h3>

<p>В качестве примера, вычислим значение $10^8!$ по модулю $10^9 + 7$:</p>

<pre class="prettyprint linenums">
const long long MOD = 1e9 + 7;

long long fact_mod() {
    long long result = 1;

    for (int i = 1; i &lt;= 100000000; i++) {
        result *= i;
        result %= MOD;  //Самая важная строка.
    }

    return result;
}
</pre>

<p>Как видите, на практике вычисления в поле по модулю отличаются от обычных
лишь наличием взятия всех промежуточных результатов по модулю (строка 8).
Однако существует два момента, которые нужно всегда учитывать для избежания
ошибок:</p>

<ul>
    <li>
        <h4>Взятие отрицательных чисел по модулю.</h4>
        <p>Согласно математическому определению, $-1 \bmod 5 = 4$, так как $-1 = -1 * 5 + 4$.
        К сожалению, оператор <code>%</code> в С++ реализован иначе, и по его версии $-1 \bmod 5 = -1$.
        Это может привести к ошибкам в вычислениях, поэтому нужно вручную обрабатывать такие
        случаи следующим образом:</p>

        <pre class="prettyprint">
long long result;
//...
result -= x;
result %= MOD;
if (result &lt; 0) result += MOD;   //Теперь всё должно работать.
        </pre>
    </li>

    <li>
        <h4>Переполнение типа <code>int</code> при умножении.</h4>
        <p>Не рекомендуется использовать тип <code>int</code> для хранения чисел по модулю
        1000000007, так как при умножении двух таких чисел результат может достигать $10^{18}$,
        что вызывет переполнение. При умножении чисел по модулю всегда используйте тип
        <code>long long</code>!</p>
    </li>
</ul>

<h3>Возведение в степень по модулю. Бинарное возведение в степень</h3>

<p>Возможность умножения по модулю позволяет нам естественным образом возводить
числа в различные степени по модулю. При операциях в поле по модулю степени часто
сильно превышают привычные значения, и тривиальный алгоритм с линейным временем
работы оказывается неприменимым. В таких ситуациях чаще всего используется
алгоритм бинарного возведения в степень.</p>

<p>Алгоритм бинарного возведения в степень достаточно лаконичен. Его идея
заключается в том, чтобы использовать возведение в квадрат промежуточных
результатов, когда это возможно. Используется следующее очевидное свойство:</p>

$$x^{2n} = x^n * x^n$$

<p>Таким образом засчёт одной операции умножения можно уменьшить степень вдвое.
Если же текущая степень нечётная, то можно просто уменьшить её на единицу простым
умножением, и получить чётную.</p>

<p>Простой рекурсивный вариант на C++:</p>

<pre class="prettyprint linenums lang-c">
const long long MOD = 1e9 + 7;

//base ^ p
long long bin_pow(long long base, long long p) {
    if (p == 1) {
        return base;    //Выход из рекурсии.
    }

    if (p % 2 == 0) {
        long long t = bin_pow(base, p / 2);
        return t * t % MOD;
    } else {
        return bin_pow(base, p - 1) * base % MOD;
    }
}
</pre>

<p>Выигрыш в скорости работы более заметен при итеративной реализации:</p>

<pre class="prettyprint linenums lang-c">
const long long MOD = 1e9 + 7;

//base ^ p
long long bin_pow(long long base, long long p) {
    long long result = base;

    while (p > 1) {
        if (p % 2 == 0) {       //Если степень чётная
            result *= result;   //Мы возводим промежуточный результат в квадрат.
            result %= MOD;
            p /= 2;             //И возводим результат в степень в два раза меньшую.
        } else {
            result *= base;
            result %= MOD;
            p--;
        }
    }

    return base;
}
</pre>

<p>Видно, что в худшем случае на каждой второй итерации
степень будет уменьшаться вдвое. Значит, время работы алгоритма можно оценить
как $O(\log p)$.</p>

<p>Разумеется, бинарное возведение в степень можно использовать и без модуля,
но степени в таких случаях слишком малы, чтобы заметить разницу в скорости.</p>

<h3>Деление в поле по модулю</h3>

<p>К сожалению, деление не так легко адаптируется к полю по модулю, как другие
арифметические операции. В этом разделе описывается один из способов деления
по модулю, но не приводится его доказательство, так как оно значительно
усложнило бы эту лекцию.</p>

<p>С делением по модулю связана одна особенность. Чтобы операция $a/b \bmod m$
имела смысл, необходимо, чтобы числа $b$ и $m$ были взаимнопростыми. Если модуль
$m$ &ndash; простое число, он является взаимнопростым со всеми числами по модулю
$m$, то есть, делить можно на все числа. Но если модуль составной, то операция
деления имеет смысл лишь для некоторых чисел, и определяется значительно сложнее.
На практике считается, что делить можно <em>только</em> в поле по простому модулю.</p>

<p>Деление по модулю определяется через умножение следующим образом:</p>

$${a \over b} \bmod b = (a * {1 \over b}) \bmod m = ab^{-1} \bmod m.$$

<p>Ключевую роль играет значение $b^{-1}$, называющееся <em>обратный элемент в
поле по модулю</em>. Оно никак не связано с классическим понятием обратного
числа, хотя бы тем, что всегда является целым (так как в поле по модулю
существуют только целые числа). Для обратного элемента должно выполняться
следующее условие:</p>

$$(x * x^{-1}) \bmod m = 1.$$

<p>Например, обратным элементов в поле по модулю $1000000007$ для числа $2$ является
число $500000004$, так как $(2 * 500000004) \bmod 1000000007 = 1$. Следовательно, в
поле по модулю $1000000007$ делению на $2$ соответствует умножение на $500000004$</p>

<p>Алгоритм нахождения обратного элемента в поле по <em>простому</em> модулю
достаточно прост (в реализации) и выражается следующей формулой:</p>

$$x^{-1} \bmod m = x^{m - 2} \bmod m$$

<p>Как можно заметить, число $x$ возводится в достаточно большую степень, и
линейный алгоритм в этой ситуации не подойдёт. Вот и пример необходимости
использования бинарного возведения в степень по модулю.</p>

<p>Реализация на C++:</p>

<pre class="prettyprint linenums lang-c">
const long long MOD = 1e9 + 7;

//base ^ p
long long bin_pow(long long base, long long p) {
    if (p == 1) {
        return base;
    }

    if (p % 2 == 0) {
        long long t = bin_pow(base, p / 2);
        return t * t % MOD;
    } else {
        return bin_pow(base, p - 1) * base % MOD;
    }
}

long long inverse_element(long long x) {
    return bin_pow(x, MOD - 2);
}

//(a / b) mod m
long long divide(long long a, long long b) {
    return a * inverse_element(b) % MOD;
}
</pre>

<p>Стоит заметить что из-за использования бинарного возведения в степень,
деление по модулю имеет сложность $O(\log m)$, тогда как все остальные
арифметические операции по модулю работают за $O(1)$.</p>

</body>

</html>