---
layout: topic
title: Сортировка
permalink: topics/sort
---

### Вступление

Сортировка - одна из самых распространённых подзадач, часто встречающаяся
в задачах всех уровней сложности. Существует множество алгоритмов,
решающих её - алгоритмов сортировки. В стандартных библиотеках большинства современных
языков программирования уже содержится эффективный алгоритм сортировки, и
вам, вероятно, очень редко придётся реализовывать его самостоятельно.
Несмотря на это, в этой лекции приведены несколько алгоритмов сортировки
в целях иллюстрации.

### Постановка задачи

Простым примером сортировки является расположение набора чисел по убыванию
или возрастанию. Точное определение сортировки более обобщено: сортировка
упорядочивает заданный набор объектов согласно определённому отношению между
ними. Например, объектами могут быть числа, строки, точки в пространстве, а
отношением - обычная операция сравнения.

### Сортировка вставками (Сложность: $$O(N^2)$$)

Один из самых простых алгоритмов сортировки - сортировка вставками. Его идея
заключается в поддерживании в левой части массива отсортированного отрезка
и постепенном его расширении вправо засчёт перемещения очередного соседнего
элемента в соответствующую ему позицию.

В качестве иллюстрации вы можете посмотреть <a href="https://www.youtube.com/watch?v=ROalU379l3U">это видео.</a>

Реализация на C++:
{% highlight cpp linenos %}
& v) {
    for (int i = 0; i < v.size(); i++) {
        int j = i;
        while (j > 0 && v[j] < v[j - 1]) {
            swap(v[j], v[j - 1]);
            j--;
        }
    }
}
{% endhighlight %}


Более короткий вариант:
{% highlight cpp linenos %}
& v) {
    for (int i = 0; i < v.size(); i++) {
        for (int j = i; j > 0 && v[j] < v[j - 1]; j--) {
            swap(v[j], v[j - 1]);
        }
    }
}
{% endhighlight %}


### Сортировка слиянием (Сложность: $$O(N \log N)$$)

Теоретически доказано, что алгоритмы сортировки основанные на сравнениях
не могут работать быстрее чем за $$O(N \log N)$$. Хотя сортировка слиянием
чаще всего работает медленнее чем оптимальные алгоритмы, она интересна идеей,
проста в реализации и пригодна для использования в решении задач (хотя лучше
всё же использовать сортировку из стандартной библиотеки вашего языка).

Идея сортировки слиянием заключается в следующем: допустим мы знаем, что
массив можно разбить на две части, и каждая из них уже будет отсортирована.
Нам нужно лишь "слить" эти две части, и мы получим отсортированный массив.

Для слияния мы создаём новый массив, изначально пустой. Затем мы параллельно
идём по двум частям изначального массива и добавляем в новый массив меньший
элемент из двух текущих.

Осталось лишь понять, как нам отсортировать две части массива независимо.
На самом деле это довольно просто. Мы просто вызываем этот же алгоритм
рекурсивно для каждой части.

И снова <a href="https://www.youtube.com/watch?v=XaqR3G_NVoo">иллюстративное видео.</a>

Реализация на C++:
{% highlight cpp linenos %}
//[begin, end) - границы отрезка. Заметьте, что end не включительно.
void merge_sort(vector<int>& v, int begin, int end) {
    if (end - begin == 1) {
        return;     //Если длина отрезка == 1, то сортировать нечего.
    }

    int mid = (begin + end) / 2;
    merge_sort(v, begin, mid);
    merge_sort(v, mid, end);

    vector<int> t;
    for (int i = begin, j = mid; i < mid || j < end; ) {
        if (i == mid) {         //первая часть закончилась
            t.push_back(v[j]);
            j++;
        } else if (j == end) {  //вторая часть закончилась
            t.push_back(v[i]);
            i++;
        } else {
            if (v[i] < v[j]) {
                t.push_back(v[i]);
                i++;
            } else {
                t.push_back(v[j]);
                j++;
            }
        }
    }

    //копируем результат в изначальный массив
    for (int i = begin; i < end; i++) {
        v[i] = t[i - begin];
    }
}
{% endhighlight %}


Можно значительно сократить код до такого вида:
{% highlight cpp linenos %}
& v, int begin, int end) {
    if (end - begin == 1) {
        return;
    }

    int mid = (begin + end) / 2;
    merge_sort(v, begin, mid);
    merge_sort(v, mid, end);

    vector<int> t;
    for (int i = begin, j = mid; i + j < mid + end; ) {
        if (j == end || (i < mid && v[i] < v[j])) {
            t.push_back(v[i++]);
        } else {
            t.push_back(v[j++]);
        }
    }

    copy(t.begin(), t.end(), v.begin() + begin);    //библиотечная функция std::copy
}
{% endhighlight %}


### Алгоритм std::sort стандартной библиотеки C++ (Сложность: $$O(N \log N)$$)

Стандартный способ сортировки в C++ - использование алгоритма std::sort.
Он реализован в виде комбинации нескольких эффективных алгоритмов: quicksort и
heapsort. В подавляющем большинстве случаев при решении задач самым простым способом
сортировки будет использование этого алгоритма.

std::sort определён следующим образом:
{% highlight cpp linenos %}
void std::sort(iterator begin, iterator end);
{% endhighlight %}


В C++ возможно автоматическое преобразование указателей в итераторы, поэтому
std::sort можно использовать для сортировки обычных массивов следующим образом:

{% highlight cpp linenos %}
int a[100];
//...
sort(a, a + 100);   //100 - длина массива.
{% endhighlight %}


### Сортировка сложных типов. Собственные компараторы

Иногда в задаче требуется отсортировать не числа, а некоторые сложные структуры,
состоящие из нескольких элементов. Для сортировки таких объектов чаще всего нужно
вручную указывать параметр, который будет сравниваться при сортировке. Для
этого и предназначены компараторы. Компаратор - функция, которая принимает два
объекта одинакового типа, и возвращает true, если первый из них "меньше" второго
и false иначе. В этом контексте "меньше" значит, что в отсортированном массиве
этот элемент обязательно должен стоять раньше.

Для использования собственного компаратора нам потребуется следующая версия функции
std::sort:

{% highlight cpp linenos %}
void std::sort(iterator begin, iterator end, comparator comp);
{% endhighlight %}


Приведём простой пример. Давайте сортировать результаты команд по системе ACM
в порядке мест. То есть, место команды выше места другой команды, если она решила
больше задач, или у неё меньше штраф:

{% highlight cpp linenos %}
struct team {
    string name;
    int tasks;      //решённых задач
    int penalty;    //штраф
};

bool cmp(team a, team b) {
    if (a.tasks > b.tasks) {
        return true;
    } else if (a.tasks < b.tasks) {
        return false;
    } else {
        return a.penalty < b.penalty;
    }
}

int main() {
    vector<team> teams;
    //...
    sort(teams.begin(), teams.end(), cmp);
}
{% endhighlight %}


Такая сортировка будет работать правильно.

При написании собственных компараторов следует помнить об одном важном правиле:
транзитивности. Компаратор является транзитивным, если из условий A < B и
B < C гарантированно следует, что A < C. Это может казаться очевидным, но для
необычных компараторов, иногда применяющихся в сложных задачах, это правило
может не выполняться. В таком случае результат работы функции sort не определён.
Всегда следите за транзитивностью компараторов!

Неочевидным моментом в работе компаратора является различие между случаями
A = B и A > B. На самом деле, это не проблема. Если алгоритму, использующему компаратор
потребуется ответ, верно ли, что A = B, он просто воспользуется условием
$$not(A < B)\ and\ not(B < A)$$.
Вам, как автору компаратора, разбирать эти случаи не нужно.

В определённых случаях свой компаратор писать не требуется. А именно, если
для данного типа определён оператор "<", то он будет использован как компаратор
по умолчанию. Например, благодаря этому, для сортировки чисел нам не требуется
компаратор.

Стоит также отдельно упомянуть стандартный тип pair. Для него также
как и для чисел, определён оператор "<" следующим образом: если первые элементы
пар отличаются, то сравниваются они, иначе сравниваются вторые элементы. Другими
словами, сортировка пар без компаратора происходит по возрастанию первого
элемента, а при равенстве первых - по возрастанию второго.

### Понятие стабильной сортировки

Иногда от сортировки нам требуется определённое условие: она не должна менять
местами "равные" элементы. Это может показаться бессмысленным, но стоит вспомнить
о компараторах для сложных типов. Достаточно просто посмотреть на пример из
предыдущего раздела. Структура team состояла из названия, количества решённых
задач и штрафа, но компаратор использовал только последние 2 параметра, никак не
задействуя названия.

{% highlight cpp linenos %}
//согласно нашему компаратору, две команды могут быть "равны",
//даже если их названия отличаются
struct team {
    string name;    //не используется при сравнении
    int tasks;
    int penalty;
}
{% endhighlight %}


Стабильная сортировка гарантирует, что при наличии таких объектов в
изначальном массиве, их относительное положение не изменится.

Пример: пусть у нас есть следующий набор команд:

{% highlight cpp linenos %}
{"Team BSEU", 9, 200}
{"Team BSU", 10, 350}
{"Team BSUIR", 9, 200}
{% endhighlight %}


Существует два "корректных" варианта их сортировки:

{% highlight cpp linenos %}
{"Team BSU", 10, 350}
{"Team BSEU", 9, 200}
{"Team BSUIR", 9, 200}
{% endhighlight %}


и

{% highlight cpp linenos %}
{"Team BSU", 10, 350}
{"Team BSUIR", 9, 200}
{"Team BSEU", 9, 200}
{% endhighlight %}


Нестабильная сортировка (например, std::sort) может отсортировать набор
обоими способами. Стабильная сортировка может получить только первый вариант,
так как относительное положение команд BSEU и BSUIR в нём сохраняется.

В стандартной библиотеке C++ уже приведена оптимальная реализация алгоритма
стабильной сортировки, работающая за время $$O(N \log N)$$. Как и std::sort,
она имеет следующие определения:

{% highlight cpp linenos %}
void std::stable_sort(iterator begin, iterator end);
void std::stable_sort(iterator begin, iterator end, comparator comp);
{% endhighlight %}


Разумеется, за стабильность приходится платить другими характеристиками.
Стабильная сортировка работает медленнее, чем нестабильная, хотя их асипмтотика
одинаковая: $$O(N \log N)$$.
