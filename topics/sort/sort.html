---
layout: topic
title: Сортировка
permalink: topics/sort
---

<h3>Вступление</h3>

<p>Сортировка &ndash; одна из самых распространённых подзадач, часто встречающаяся
в задачах всех уровней сложности. Существует множество алгоритмов, решающих её
&ndash; алгоритмов сортировки. В стандартных библиотеках большинства современных
языков программирования уже содержится эффективный алгоритм сортировки, и
вам, вероятно, очень редко придётся реализовывать его самостоятельно.
Несмотря на это, в этой лекции приведены несколько алгоритмов сортировки
в целях иллюстрации.</p>

<h3>Постановка задачи</h3>

<p>Простым примером сортировки является расположение набора чисел по убыванию
или возрастанию. Точное определение сортировки более обобщено: сортировка
упорядочивает заданный набор объектов согласно определённому отношению между
ними. Например, объектами могут быть числа, строки, точки в пространстве, а
отношением &ndash; обычная операция сравнения.</p>

<h3>Сортировка вставками (Сложность: $$O(N^2)$$)</h3>

<p>Один из самых простых алгоритмов сортировки &ndash; сортировка вставками. Его идея
заключается в поддерживании в левой части массива отсортированного отрезка
и постепенном его расширении вправо засчёт перемещения очередного соседнего
элемента в соответствующую ему позицию.</p>

<p>В качестве иллюстрации вы можете посмотреть <a href="https://www.youtube.com/watch?v=ROalU379l3U">это видео.</a></p>

<p>Реализация на C++:</p>
<pre><code class="language-cpp line-numbers">void insertion_sort(vector&lt;int&gt;&amp; v) {
    for (int i = 0; i &lt; v.size(); i++) {
        int j = i;
        while (j &gt; 0 &amp;&amp; v[j] &lt; v[j - 1]) {
            swap(v[j], v[j - 1]);
            j--;
        }
    }
}
</code></pre>

<p>Более короткий вариант:</p>
<pre><code class="language-cpp line-numbers">void insertion_sort(vector&lt;int&gt;&amp; v) {
    for (int i = 0; i &lt; v.size(); i++) {
        for (int j = i; j &gt; 0 &amp;&amp; v[j] &lt; v[j - 1]; j--) {
            swap(v[j], v[j - 1]);
        }
    }
}
</code></pre>

<h3>Сортировка слиянием (Сложность: $$O(N \log N)$$)</h3>

<p>Теоретически доказано, что алгоритмы сортировки основанные на сравнениях
не могут работать быстрее чем за $$O(N \log N)$$. Хотя сортировка слиянием
чаще всего работает медленнее чем оптимальные алгоритмы, она интересна идеей,
проста в реализации и пригодна для использования в решении задач (хотя лучше
всё же использовать сортировку из стандартной библиотеки вашего языка).</p>

<p>Идея сортировки слиянием заключается в следующем: допустим мы знаем, что
массив можно разбить на две части, и каждая из них уже будет отсортирована.
Нам нужно лишь "слить" эти две части, и мы получим отсортированный массив.</p>

<p>Для слияния мы создаём новый массив, изначально пустой. Затем мы параллельно
идём по двум частям изначального массива и добавляем в новый массив меньший
элемент из двух текущих.</p>

<p>Осталось лишь понять, как нам отсортировать две части массива независимо.
На самом деле это довольно просто. Мы просто вызываем этот же алгоритм
рекурсивно для каждой части.</p>

<p>И снова <a href="https://www.youtube.com/watch?v=XaqR3G_NVoo">иллюстративное видео.</a></p>

<p>Реализация на C++:</p>
<pre><code class="language-cpp line-numbers">//[begin, end) - границы отрезка. Заметьте, что end не включительно.
void merge_sort(vector&lt;int&gt;&amp; v, int begin, int end) {
    if (end - begin == 1) {
        return;     //Если длина отрезка == 1, то сортировать нечего.
    }

    int mid = (begin + end) / 2;
    merge_sort(v, begin, mid);
    merge_sort(v, mid, end);

    vector&lt;int&gt; t;
    for (int i = begin, j = mid; i &lt; mid || j &lt; end; ) {
        if (i == mid) {         //первая часть закончилась
            t.push_back(v[j]);
            j++;
        } else if (j == end) {  //вторая часть закончилась
            t.push_back(v[i]);
            i++;
        } else {
            if (v[i] &lt; v[j]) {
                t.push_back(v[i]);
                i++;
            } else {
                t.push_back(v[j]);
                j++;
            }
        }
    }

    //копируем результат в изначальный массив
    for (int i = begin; i &lt; end; i++) {
        v[i] = t[i - begin];
    }
}
</code></pre>

<p>Можно значительно сократить код до такого вида:</p>
<pre><code class="language-cpp line-numbers">void merge_sort(vector&lt;int&gt;&amp; v, int begin, int end) {
    if (end - begin == 1) {
        return;
    }

    int mid = (begin + end) / 2;
    merge_sort(v, begin, mid);
    merge_sort(v, mid, end);

    vector&lt;int&gt; t;
    for (int i = begin, j = mid; i + j &lt; mid + end; ) {
        if (j == end || (i &lt; mid &amp;&amp; v[i] &lt; v[j])) {
            t.push_back(v[i++]);
        } else {
            t.push_back(v[j++]);
        }
    }

    copy(t.begin(), t.end(), v.begin() + begin);    //библиотечная функция std::copy
}
</code></pre>

<h3>Алгоритм std::sort стандартной библиотеки C++ (Сложность: $$O(N \log N)$$)</h3>

<p>Стандартный способ сортировки в C++ &ndash; использование алгоритма std::sort.
Он реализован в виде комбинации нескольких эффективных алгоритмов: quicksort и
heapsort. В подавляющем большинстве случаев при решении задач самым простым способом
сортировки будет использование этого алгоритма.</p>

<p>std::sort определён следующим образом:</p>
<pre><code class="language-cpp line-numbers">void std::sort(iterator begin, iterator end);
</code></pre>

<p>В C++ возможно автоматическое преобразование указателей в итераторы, поэтому
std::sort можно использовать для сортировки обычных массивов следующим образом:</p>

<pre><code class="language-cpp line-numbers">int a[100];
//...
sort(a, a + 100);   //100 - длина массива.
</code></pre>

<h3>Сортировка сложных типов. Собственные компараторы</h3>

<p>Иногда в задаче требуется отсортировать не числа, а некоторые сложные структуры,
состоящие из нескольких элементов. Для сортировки таких объектов чаще всего нужно
вручную указывать параметр, который будет сравниваться при сортировке. Для
этого и предназначены компараторы. Компаратор - функция, которая принимает два
объекта одинакового типа, и возвращает true, если первый из них "меньше" второго
и false иначе. В этом контексте "меньше" значит, что в отсортированном массиве
этот элемент обязательно должен стоять раньше.</p>

<p>Для использования собственного компаратора нам потребуется следующая версия функции
std::sort:</p>

<pre><code class="language-cpp line-numbers">void std::sort(iterator begin, iterator end, comparator comp);
</code></pre>

<p>Приведём простой пример. Давайте сортировать результаты команд по системе ACM
в порядке мест. То есть, место команды выше места другой команды, если она решила
больше задач, или у неё меньше штраф:</p>

<pre><code class="language-cpp line-numbers">struct team {
    string name;
    int tasks;      //решённых задач
    int penalty;    //штраф
};

bool cmp(team a, team b) {
    if (a.tasks &gt; b.tasks) {
        return true;
    } else if (a.tasks &lt; b.tasks) {
        return false;
    } else {
        return a.penalty &lt; b.penalty;
    }
}

int main() {
    vector&lt;team&gt; teams;
    //...
    sort(teams.begin(), teams.end(), cmp);
}
</code></pre>

<p>Такая сортировка будет работать правильно.</p>

<p>При написании собственных компараторов следует помнить об одном важном правиле:
транзитивности. Компаратор является транзитивным, если из условий A &lt; B и
B &lt; C гарантированно следует, что A &lt; C. Это может казаться очевидным, но для
необычных компараторов, иногда применяющихся в сложных задачах, это правило
может не выполняться. В таком случае результат работы функции sort не определён.
Всегда следите за транзитивностью компараторов!</p>

<p>Неочевидным моментом в работе компаратора является различие между случаями
A = B и A &gt; B. На самом деле, это не проблема. Если алгоритму, использующему компаратор
потребуется ответ, верно ли, что A = B, он просто воспользуется условием
$$not(A &lt; B)\ and\ not(B &lt; A)$$.
Вам, как автору компаратора, разбирать эти случаи не нужно.</p>

<p>В определённых случаях свой компаратор писать не требуется. А именно, если
для данного типа определён оператор "&lt;", то он будет использован как компаратор
по умолчанию. Например, благодаря этому, для сортировки чисел нам не требуется
компаратор.</p>

<p>Стоит также отдельно упомянуть стандартный тип pair. Для него также
как и для чисел, определён оператор "&lt;" следующим образом: если первые элементы
пар отличаются, то сравниваются они, иначе сравниваются вторые элементы. Другими
словами, сортировка пар без компаратора происходит по возрастанию первого
элемента, а при равенстве первых &ndash; по возрастанию второго.</p>

<h3>Понятие стабильной сортировки</h3>

<p>Иногда от сортировки нам требуется определённое условие: она не должна менять
местами "равные" элементы. Это может показаться бессмысленным, но стоит вспомнить
о компараторах для сложных типов. Достаточно просто посмотреть на пример из
предыдущего раздела. Структура team состояла из названия, количества решённых
задач и штрафа, но компаратор использовал только последние 2 параметра, никак не
задействуя названия.</p>

<pre><code class="language-cpp line-numbers">//согласно нашему компаратору, две команды могут быть "равны",
//даже если их названия отличаются
struct team {
    string name;    //не используется при сравнении
    int tasks;
    int penalty;
}
</code></pre>

<p>Стабильная сортировка гарантирует, что при наличии таких объектов в
изначальном массиве, их относительное положение не изменится.</p>

<p>Пример: пусть у нас есть следующий набор команд:</p>

<pre><code class="language-cpp line-numbers">{"Team BSEU", 9, 200}
{"Team BSU", 10, 350}
{"Team BSUIR", 9, 200}
</code></pre>

<p>Существует два "корректных" варианта их сортировки:</p>

<pre><code class="language-cpp line-numbers">{"Team BSU", 10, 350}
{"Team BSEU", 9, 200}
{"Team BSUIR", 9, 200}
</code></pre>

<p>и</p>

<pre><code class="language-cpp line-numbers">{"Team BSU", 10, 350}
{"Team BSUIR", 9, 200}
{"Team BSEU", 9, 200}
</code></pre>

<p>Нестабильная сортировка (например, std::sort) может отсортировать набор
обоими способами. Стабильная сортировка может получить только первый вариант,
так как относительное положение команд BSEU и BSUIR в нём сохраняется.</p>

<p>В стандартной библиотеке C++ уже приведена оптимальная реализация алгоритма
стабильной сортировки, работающая за время $$O(N \log N)$$. Как и std::sort,
она имеет следующие определения:</p>

<pre><code class="language-cpp line-numbers">void std::stable_sort(iterator begin, iterator end);
void std::stable_sort(iterator begin, iterator end, comparator comp);
</code></pre>

<p>Разумеется, за стабильность приходится платить другими характеристиками.
Стабильная сортировка работает медленнее, чем нестабильная, хотя их асипмтотика
одинаковая: $$O(N \log N)$$.</p>
