---
layout: topic
title: Двудольные графы. Проверка графа на двудольность
permalink: topics/bipartite
---

<h3>Определение двудольного графа</h3>

<p>Двудольный граф &ndash; граф, вершины которого можно разбить на два множества
так, что каждое ребро соединяет вершины из разных множеств.</p>

<img style="display: block; margin: auto" src="/resources/Simple-bipartite-graph.png" />

<p>Часто в контексте двудольных графов используется понятие <em>цвета</em>
вершины. Разбитие графа на две доли называется <em>покраской</em> его вершин
в два различных цвета. Каждое ребро должно соединять вершины различного цвета.</p>

<img style="display: block; margin: auto" src="/resources/bipartite_colors.png" />

<p>Существует ещё один признак двудольности графа: граф является двудольным тогда
и только тогда, когда в нём отсутствуют циклы нечётной длины.</p>

<h3>Проверка графа на двудольность</h3>

<p>Для проверки графа на двудольность и разбития его на доли чаще всего
используется DFS.</p>

<p>Начинаем покраску с произвольной вершины, которую красим в произвольный цвет.
При прохождении по каждому ребру красим следующую вершину в противоположный цвет.
Если при переборе соседних вершин мы нашли вершину, уже покрашенную в тот же
цвет, что и текущая, то в графе существует нечётный цикл, а значит, он не
является двудольным.</p>

<h3>Реализация</h3>

<pre><code class="language-cpp line-numbers">#include &lt;bits/stdc++.h&gt;

using namespace std;

vector&lt;int&gt; graph[100000];
char color[100000];     //Цвет будем представлять типом char
                        //0 - вершина ещё не покрашена; 1, 2 - различные цвета.

inline char invert(int c) {
    return c == 1 ? 2 : 1;
}

void dfs(int v, char c) {   //c - цвет текущей вершины
    color[v] = c;

    for (int u: graph[v]) {
        if (color[u] == 0) {    //непосещённая вершина
            dfs(u, invert(c));
        } else if (color[u] == c) {
            cout &lt;&lt; "Graph is not bipartite." &lt;&lt; endl;
            exit(0);
        }
    }
}

int main() {
    //Ввод графа...

    //Двудольный граф может быть несвязным (тогда существуют несколько способов покраски).
    for (int i = 0; i &lt; n; i++) {
        if (color[i] == 0) {
            dfs(i, 1);
        }
    }

    cout &lt;&lt; "Graph is bipartite." &lt;&lt; endl;
}
</code></pre>

<h3>Хроматическое число графа</h3>

<p>Определение двудольных графов обобщается на произвольное количество цветов.
<strong>Хроматическим числом</strong> графа называется минимальное количество
цветов, в которые можно покрасить его вершины так, чтобы каждое ребро соединяло
вершины различного цвета. Хроматическое число двудольных графов равно $2$, а
хроматическое число графа, изображённого ниже, равно $3$.</p>

<img style="display: block; margin: auto" src="/resources/tripartite_graph.png" />

<p>Задача проверки возможности покраски графа $k$ цветами при $k \ge 3$ не имеет
эффективного (<strong>полиномиального</strong>) решения. Единственным доказанным
решением является полный перебор всех покрасок за $O(k^N)$. Эта задача является
классической <strong>NP-полной</strong> (не имеющей полиномиального решения) задачей.</p>
