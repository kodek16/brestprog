---
layout: topic
title: "Понятие и представление графа: матрица смежности, список смежности"
permalink: topics/graphs
---

<h3>Определение графа</h3>

<p>Графы &ndash; фундаментальное понятие как в математике, так и в информатике.
Проще всего объяснить его с помощью аналогии с дорожной системой. Существует
определённый набор городов, некоторые из которых связаны дорогами, которые
могут быть как односторонними, так и двухсторонними. Вся эта структура и
называется графом.</p>

<o>Ну а более формально, граф &ndash; комбинация набора вершин и набора рёбер.
Вершины &ndash; это города, а рёбра &ndash; дороги. Визуально граф можно
представить так:</p>

<img style="display: block; margin: auto" src="/resources/6n-graf.png" />

<p>Этот граф состоит из 6 вершин, пронумерованных начиная с единицы, и 7
двухсторонних рёбер. Рёбра обычно записывают в виде пар вершин, которые они
соединяют: $$1$$-$$2$$, $$1$$-$$5$$, $$2$$-$$3$$, $$2$$-$$5$$, $$3$$-$$4$$, $$4$$-$$5$$, $$4$$-$$6$$.</p>

<h3>Ориентированные и неориентированные графы</h3>

<p>Мы уже упоминали, что "дороги" в графе могут быть как односторонними, так
и двухсторонними. Для этого свойства существует отдельный термин: односторонние
"дороги" называются ориентированными рёбрами (или дугами), а двухсторонние
&ndash; неориентированными.</p>

<p>Граф, в котором все рёбра неориентированные, также называют неориентированным,
а граф с ориентированными рёбрами, соответственно, ориентированным.</p>

<div style="display: block; width: 600px; margin: auto">
    <img src="/resources/Undirected.png" />
    <img src="/resources/Directed.png" />
</div>

<p>Слева изображён неориентированный граф, а справа &ndash; ориентированный. Как
несложно догадаться, левый граф можно обходить как по часовой стрелке, так и
против, а правый можно полностью обойти только по часовой, хотя одно из ребёр в
нём также неориентированное (считается, что это два противоположных
ориентированных ребра).</p>

<h3>Пути и циклы</h3>

<p>Путём в графе называется последовательность вершин, каждая из которых
соединена со следующей ребром. Чаще всего под "путём" подразумевают простой
путь, все вершины которого различны. Путь, который проходит через какую-либо
вершину более одного раза называют сложным путём.</p>

<p>Если первая вершина пути совпадает с последней, то такой путь называют
циклом.</p>

<p>Приведём примеры на этом графе:</p>

<img style="display: block; margin: auto" src="/resources/Cyclic-graph.png" />

<p>Из множества возможных простых путей самый длинный: $$a - f - c - d - e - b - h$$
(существуют и другие пути с такой же длиной).</p>

<p>Циклом является путь $$b - c - d - e - b$$ (выделен цветом). Можно начать и
с любой другой вершины, например, $$c - d - e - b - c$$.</p>

<h3>Кратные рёбра и петли</h3>

<p>Существует множество разновидностей графов, и среди них встречаются довольно
специфические. В частности, так называемые мультиграфы разрешают наличие между
двумя вершинами нескольких рёбер (называемых кратными рёбрами), а также
наличие петель. Петля &ndash; ребро, входящее в ту же вершину, из которой
исходит. Выглядят они следующим образом:</p>

<img style="display: block; margin: auto" src="/resources/Multi-pseudograph.png" />

<p>Красным выделены кратные рёбра, а синим &ndash; петли.</p>

<p>Мультиграфы встречаются в задачах реже чем обычные графы (называемые простыми),
но всё же встречаются, поэтому стоит иметь о них элементарное представление.</p>

<h3>Связные графы</h3>

<p>Граф называется связным если между любой парой вершин существует хотя бы
один путь. Как пример рассмотрим следующий граф:</p>

<img style="display: block; margin: auto" src="/resources/Sample-graph.jpg" />

<p>Одно из рёбер проведено штрихами. Если это ребро присутствует, то граф
является связным. Если же его убрать, то связность теряется, граф разбивается
на две части, друг с другом не связанные. Такие части называются компонентами
связности.</p>

<h3>Определение дерева</h3>

<p>Дерево &ndash; вид графа, который можно назвать самым простым, но они
обладают множеством особых свойств и встречаются в задачах чуть ли не чаще
остальных графов.</p>

<p><strong>Дерево &ndash; это связный граф без циклов, петель и кратных рёбер.</strong></p>

<p>Все изображённые графы являются деревьями:</p>

<table>
    <tr>
        <td><img style="display: block; margin: auto; max-width: 400px; max-height: 300px" src="/resources/Tree1.png" /></td>
        <td><img style="display: block; margin: auto; max-width: 400px; max-height: 300px" src="/resources/Tree2.png" /></td>
    </tr>
    <tr>
        <td><img style="display: block; margin: auto; max-width: 400px; max-height: 300px" src="/resources/Tree3.png" /></td>
        <td><img style="display: block; margin: auto; max-width: 400px; max-height: 300px" src="/resources/Tree4.png" /></td>
    </tr>
</table>

<p>Среди множества свойств деревьев можно выделить два самых известных:</p>

<ul>
    <li>Количество рёбер связано с количеством вершин формулой $$E = V - 1$$.</li>
    <li>Между любой парой вершин существует ровно один путь.</li>
</ul>

<h3>Матрица смежности</h3>

<p>Существует два основных способа представления графов в программировании.
Один из них, матрица смежности, используется гораздо реже, но очень просто
реализуется. Граф из $$N$$ вершин задаётся матрицей (двумерным массивом) $$N * N$$,
в которой $$g[i][j]$$ &ndash; логическое значение, <code>true</code> или
<code>false</code>, обозначающее, существует ли ребро из вершины $$i$$ в вершину
$$j$$.</p>

<p>В качестве примера решим простую задачу: для каждой вершины графа выведем
количество рёбер, смежных с ней.</p>

<pre><code class="language-cpp line-numbers">#include &lt;bits/stdc++.h&gt;

using namespace std;

bool graph[1000][1000];

int main() {
    int n, m;       //количество вершин и рёбер соответственно
    cin >> n >> m;

    for (int i = 0; i &lt; m; i++) {
        int u, v;   //номера вершин, соединённых очередным ребром
        cin >> u >> v;

        u--, v--;   //Здесь стоит остановиться и вдуматься.
                    //Чаще всего в задачах вершины будут нумероваться с 1 до N,
                    //в отличие от индексации массивов в C++.

                    //У этой проблемы есть два решения.
                    //Первое: работать с номерами "как есть": создавать массивы размером N + 1,
                    //использовать циклы от 1 до N, и т.д.
                    //Второе: уменьшать номера вершин на единицу при вводе, и увеличивать обратно при выводе

                    //Какое из них использовать - ваш личный выбор.
                    //Для меня 1-индексация в С++ выглядит очень чужеродно, поэтому я использую второе решение.

        graph[u][v] = graph[v][u] = true;   //Если бы граф был ориентированным, то обратное ребро мы бы не создавали.
    }

    for (int i = 0; i &lt; n; i++) {
        int c = 0;
        for (int j = 0; j &lt; n; j++) {
            if (graph[i][j]) {
                c++;
            }
        }

        cout &lt;&lt; c &lt;&lt; " edges adjacent to vertex " &lt;&lt; i + 1 &lt;&lt; endl;
    }
}
</code></pre>

<p>Преимущества матрицы смежности:</p>
<ul>
    <li>Сложность проверки наличия ребра между двумя вершинами: $$O(1)$$</li>
</ul>

</p>Недостатки матрицы смежности:</p>
<ul>
    <li>Занимает $$N^2$$ памяти, что неприемлемо для достаточно больших графов.</li>
    <li>Сложность перебора всех вершин, смежных с данной: $$O(N)$$</li>
</ul>

<h3>Список смежности</h3>

<p>Гораздо чаще для представления графов используется список смежности. Его
идея заключается в хранении для каждой вершины расширяемого массива (вектора),
содержащего всех её соседей.</p>

<p>Решим ту же задачу с использованием списка смежности (и С++11 для for-each):</p>

<pre><code class="language-cpp line-numbers">#include &lt;bits/stdc++.h&gt;

using namespace std;

vector&lt;int&gt; graph[100000];    //массив из 100000 векторов.

int main() {
    int n, m;
    cin >> n >> m;

    for (int i = 0; i &lt; m; i++) {
        int u, v;
        cin >> u >> v;
        u--, v--;

        graph[u].push_back(v);
        graph[v].push_back(u);
    }

    for (int i = 0; i &lt; n; i++) {
        int c = 0;
        for (int v: graph[i]) {     //можно было бы просто записать "int c = graph[i].size();",
            c++;                    //но такая реализация показывает, как можно перебирать
        }                           //соседние вершины.

        cout &lt;&lt; c &lt;&lt; " edges adjacent to vertex " &lt;&lt; i + 1 &lt;&lt; endl;
    }
}
</code></pre>

<p>Если требуется также удалять рёбра, то вместо вектора нужно использовать
<code>std::set</code>.

<p>Преимущества списка смежности:</p>
<ul>
    <li>Использует $$O(M)$$ памяти, что оптимально.</li>
    <li>Позволяет быстро перебирать соседей вершины.</li>
    <li>Позволяет за $$O(\log N)$$ проверять наличие ребра и удалять его (при использовании <code>std::set</code>).</li>
</ul>

</p>Недостатки списка смежности:</p>
<ul>
    <li>При работе с насыщенными графами (количество рёбер близко к $$N^2$$)
    скорости $$O(\log N)$$ может не хватать (единственный повод использовать матрицу смежности).</li>
    <li>Для взвешенных графов приходится хранить <code>vector&lt;pair&lt;int, int&gt;&gt;</code>, что
    усложняет код.</li>
</ul>
