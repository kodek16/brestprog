---
layout: topic
title: Поиск компонент связности
permalink: topics/connectivity
---

<h3>Определение компоненты связности</h3>

<p>Понятие компоненты связности вытекает из понятия связности графа. Попросту
говоря, компонента связности &ndash; часть графа (подграф), являющаяся связной.
Формально, компонента связности &ndash; набор вершин графа, между любой парой
которых существует путь.</p>

<img style="display: block; margin: auto" src="/resources/connectivity.png" />

<p>Граф на иллюстрации содержит три компоненты связности, закрашенные разными
цветами. Можно заметить, что даже одна вершина, изолированная от остального
графа, составляет компоненту связности.</p>

<p>Общее понятие связности распространяется только на неориентированные графы.
Для описания ориентированных графов используются понятия <em>сильной</em> и <em>слабой</em>
связности, но они выходят за границы материала этой лекции.</p>

<h3>Алгоритм поиска компонент связности</h3>

<p>Для поиска компонент связности используется обычный DFS практически без
модификаций (можно использовать и BFS). При запуске обхода из одной вершины, он
гарантированно посетит все вершины, до которых возможно добраться, то есть,
всю компоненту связности, к которой принадлежит начальная вершина. Для нахождения
всех компонент просто попытаемся запустить обход из каждой вершины по очереди,
если мы ещё не обошли её компоненту ранее.</p>

<h3>Реализация</h3>

<p>Приведём два варианта реализации с разным способом хранения компонент связности.</p>

<p>Простейший вариант: просто заполнить массив $comp$, где $comp[i]$ &ndash; номер
компоненты связности, к которой принадлежит вершина $i$.</p>

<pre><code class="language-cpp line-numbers">#include &lt;bits/stdc++.h&gt;

using namespace std;

vector&lt;int&gt; graph[100000];
bool used[100000];
int comp[100000];

void dfs(int v, int c_num) {    //c_num - номер текущей компоненты связности.
    used[v] = true;
    comp[v] = c_num;

    for (int u: graph[v]) {
        if (!used[u]) {
            dfs(u, c_num);
        }
    }
}

int main() {
    //Ввод графа...

    int c_num = 1;  //Номер очередной компоненты.
                    //Нумеровать можно как с 0, так и с 1, как вам удобнее.

    for (int i = 0; i &lt; n; i++) {
        if (!used[i]) {     //если мы ещё не посетили эту вершину, обходя одну из предыдущих
            dfs(i, c_num);
            c_num++;
        }
    }

    for (int i = 0; i &lt; n; i++) {
        cout &lt;&lt; "Vertex " &lt;&lt; i + 1 &lt;&lt; " belongs to component " &lt;&lt; comp[i] &lt;&lt; endl;
    }
}
</code></pre>

<p>Другой вариант: явно хранить для каждой компоненты вектор из вершин, входящих
в неё. Компоненты (векторы) хранить в векторе (из векторов).</p>

<pre><code class="language-cpp line-numbers">#include &lt;bits/stdc++.h&gt;

using namespace std;

vector&lt;int&gt; graph[100000];
bool used[100000];

vector&lt;vector&lt;int&gt;&gt; comps;

void dfs(int v) {   //информацию о компоненте в DFS больше передавать не нужно,
                    //он просто будет добавлять вершины в последний вектор в comps.
    used[v] = true;
    comps.back().push_back(v);

    for (int u: graph[v]) {
        if (!used[u]) {
            dfs(u);
        }
    }
}

int main() {
    //Ввод графа...

    for (int i = 0; i &lt; n; i++) {
        if (!used[i]) {
            comps.push_back(vector&lt;int&gt;());   //добавляем в comps новый пустой вектор,
                                              //в который DFS будет записывать посещённые вершины.
            dfs(i);
        }
    }

    for (vector&lt;int&gt;&amp; comp: comps) {
        cout &lt;&lt; "Component: ";
        for (int v: comp) {
            cout &lt;&lt; v + 1 &lt;&lt; ", ";
        }
        cout &lt;&lt; endl;
    }
}
</code></pre>
