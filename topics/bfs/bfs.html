---
layout: topic
title: Обход в ширину (BFS)
permalink: topics/bfs
---

<h3>Определение</h3>

<p>Под обходом понимается последовательное посещение (обработка) вершин графа в
определённом порядке. Одним из двух часто использующихся способов обхода
является обход в ширину, или BFS (<em>англ.</em> breadth-first search, поиск в
ширину). Его иногда также называют волновым, по аналогии с распространяющейся
волной.</p>

<p>Суть BFS достаточно проста. Обход начинается с посещения определённой вершины
(для обхода всего графа часто выбирается произвольная вершина). Затем алгоритм
посещает соседей этой вершины. За ними &ndash; соседей соседей, и так далее.</p>

<p>Более формально, пусть $$d[i]$$ &ndash; расстояние от начальной вершины до
вершины с номером $$i$$ (длина кратчайшего пути в рёбрах). BFS посещает вершины
в порядке возрастания $$d[i]$$: от наименее до наиболее отдалённых.</p>

<img style="display: block; margin: auto; width: 500px" src="/resources/Animated_BFS.gif" />

<p>Серым помечены вершины в очереди на посещение, чёрным &ndash; уже посещённые.</p>

<h3>Алгоритм</h3>

<p>Как можно увидеть из иллюстрации, сам алгоритм достаточно тривиален.
Поддерживается очередь из вершин для посещения. При посещении очередной
вершины в очередь добавляются все её соседи, которые ещё не были посещены и
ещё не находятся в очереди. Для проверки, была ли вершина уже посещена,
используется массив меток. Изначально $$visited[i] = false$$ для всех $$i$$
кроме начальной вершины. При добавлении вершины $$i$$ в очередь $$visited[i]$$
присваивается $$true$$.</p>

<h3>Реализация</h3>

<p>Реализуем простой BFS для графа заданного списком смежности:</p>

<pre><code class="language-cpp line-numbers">#include &lt;bits/stdc++.h&gt;

using namespace std;

vector&lt;int&gt; graph[100000];
bool used[100000];      //вместо visited массив меток обычно называют used.

int main() {
    //Ввод графа...

    queue&lt;int&gt; q;
    q.push(0);              //в качестве начальной вершины используем 0.
    used[0] = true;

    while (!q.empty()) {
        int cur = q.front();  //извлекаем из очереди текущую вершину
        q.pop();

        //Здесь должна быть обработка текущей вершины.
        cout &lt;&lt; "BFS at vertex " &lt;&lt; cur + 1 &lt;&lt; endl;

        for (int neighbor: graph[cur]) {    //добавляем всех непосещённых соседей.
            if (!used[neighbor]) {
                q.push(neighbor);
                used[neighbor] = true;
            }
        }
    }
}
</code></pre>

<h3>Практическое применение: вычисление расстояния до всех вершин</h3>

<p>BFS по определению посещает вершины в порядке возрастания расстояния от них
до начальной. Поэтому одним из главных его применений является вычисление
расстояния от заданной вершины до всех остальных.</p>

<p>Модификация алгоритма, необходимая для этого, минимальна. Пусть при
обработке вершины $$i$$ мы добавляем в очередь вершину $$j$$. Это значит, что
кратчайший путь от начальной вершины до вершины $$j$$ проходит через вершину
$$i$$.</p>

<p style="display: block; margin: auto; width: 60%; border: 1px solid black; padding: 5px">
Доказательство: допустим, что существует более короткий путь в $$j$$, не
проходящий через $$i$$. Обозначим предпоследнюю вершину этого пути $$k$$.
Так как путь в $$j$$ через $$k$$ короче пути в $$j$$ через $$i$$ можно сделать вывод,
что расстояние до $$k$$ меньше расстояния до $$i$$. Но по определению BFS вершина
$$k$$ в таком случае была бы уже обработана, а значит, $$j$$ бы уже находилась
в очереди. Получили противоречие. Следовательно, подходящей вершины $$k$$ не
существует.
</p>

<p>Обозначим расстояние от начальной вершины до вершины $$i$$ как $$dst[i]$$.
В таком случае верно, что $$dst[j] = dst[i] + 1$$. Таким образом мы можем
рассчитать растояние для всех вершин.</p>

<p>Реализация:</p>

<pre><code class="language-cpp line-numbers">#include &lt;bits/stdc++.h&gt;

using namespace std;

vector&lt;int&gt; graph[100000];
bool used[100000];
int dst[100000];

int main() {
    //Ввод графа...

    for (int i = 0; i &lt; 100000; i++) {   //изначально заполним массив dst значением -1
        dst[i] = -1;                     //оно будет обозначать, что расстояние до этой вершины ещё неизвестно
    }

    queue&lt;int&gt; q;
    q.push(0);
    used[0] = true;
    dst[0] = 0;         //теперь при добавлении каждой вершины в очередь мы вычисляем расстояние до неё

    while (!q.empty()) {
        int cur = q.front();
        q.pop();

        for (int neighbor: graph[cur]) {
            if (!used[neighbor]) {
                q.push(neighbor);
                used[neighbor] = true;
                dst[neighbor] = dst[cur] + 1;   //вот и весь код расчёта расстояния
            }
        }
    }

    for (int i = 0; i &lt; n; i++) {
        if (dst[i] != -1) {
            cout &lt;&lt; "Distance between vertices 1 and " &lt;&lt; i + 1 &lt;&lt; " is " &lt;&lt; dst[i] &lt;&lt; endl;
        } else {
            cout &lt;&lt; "Vertex " &lt;&lt; i + 1 &lt;&lt; " cannot be reached from vertex 1." &lt;&lt; endl;
        }
    }
}
</code></pre>

<p>Стоит заметить одно важное свойство. Если существуют вершины, в которые
невозможно добраться из 1-й вершины, $$dst[i]$$ для них будет равно $$-1$$. Можно
вспомнить об определении связности графа. Если после окончания работы алгоритма
в массиве $$dst$$ осталось хоть одно значение $$-1$$, то граф не является связным.
Таким образом BFS можно также использовать для проверки на связность.</p>

<h3>BFS с сохранением пути</h3>

<p>Иногда кроме длины кратчайшего пути в задаче требуется также вывести вершины,
через которые он проходит. BFS легко модифицируется для решения этой задачи.</p>

<p>Пусть при обработке вершины $$i$$ мы добавляем в очередь вершину $$j$$. Это
значит, что кратчайший путь от начальной вершины до вершины $$j$$ проходит через
вершину $$i$$ (доказательство выше). Значит последним ребром в кратчайшем пути
до $$j$$ будет ребро $$i - j$$, а весь остальной путь будет совпадать с кратчайшим
путём до $$i$$. Просто сохраним тот факт, что предыдущей вершиной для $$j$$
является $$i$$. Для этого будем использовать массив $$prev$$. Простой пометки
$$prev[j] = i$$ хватит для восстановления пути после завершения работы алгоритма.</p>

<p>Реализация:</p>

<pre><code class="language-cpp line-numbers">#include &lt;bits/stdc++.h&gt;

using namespace std;

vector&lt;int&gt; graph[100000];
bool used[100000];
int dst[100000];
int pr[100000];   //имя prev уже используется библиотекой, поэтому назовём массив pr

int main() {
    //Ввод графа...

    for (int i = 0; i &lt; 100000; i++) {
        dst[i] = -1;
    }

    queue&lt;int&gt; q;
    q.push(0);
    used[0] = true;
    dst[0] = 0;
    pr[0] = -1;   //Пометка, означающая, что у вершины 0 нет предыдущей.

    while (!q.empty()) {
        int cur = q.front();
        q.pop();

        for (int neighbor: graph[cur]) {
            if (!used[neighbor]) {
                q.push(neighbor);
                used[neighbor] = true;
                dst[neighbor] = dst[cur] + 1;
                pr[neighbor] = cur;   //сохранение предыдущей вершины
            }
        }
    }

    //Восстановим кратчайший путь до вершины k (которую, предполагается, мы уже ввели)
    //Для восстановления пути пройдём его в обратном порядке, начиная с j, и развернём.

    vector&lt;int&gt; path;

    int cur = k;         //текущая вершина пути
    path.push_back(cur);

    while (pr[cur] != -1) {   //пока существует предыдущая вершина
        cur = pr[cur];        //переходим в неё
        path.push_back(cur);    //и дописываем к пути
    }

    reverse(path.begin(), path.end());

    cout &lt;&lt; "Shortest path between vertices 1 and " &lt;&lt; k + 1 &lt;&lt; " is: " &lt;&lt; endl;

    for (int v: path) {
        cout &lt;&lt; v + 1 &lt;&lt; ", ";
    }
}
</code></pre>

<h3>Применение BFS без явных графов</h3>

<p>Кроме собственно графов, BFS часто используется для поиска путей в
прямоугольном поле, состоящем из клеток. В этом поле находится некоторая
"фигура" которая может перемещаться согласно определённым условиям. На самом
деле, такое поле задаёт граф, вершины которого &ndash; клетки поля, а ребро
из одной клетки в другую существует, если фигура может совершить соответствующее
перемещение.</p>

<p>Такие задачи можно решать без явного построения списка смежности, работая
только с самой матрицей. В качестве примера приведём решение следующей задачи:</p>

<p style="display: block; margin: auto; width: 60%">
На шахматной доске размером $$N * N$$ ($$1 \le N \le 1000$$) в клетке $$(x_1, y_1)$$
находится конь. Определить, за сколько ходов он может попасть в клетку $$(x_2, y_2)$$.
</p>

<p>На всякий случай напомним, что конь может ходить "буквой Г" в любом
направлении. Математически это значит, что конь может изменить одну из своих
координат на $$2$$ или $$-2$$, а другую на $$1$$ или $$-1$$. Это даёт нам следующий
набор векторов, задающий ходы коня:</p>

$$(1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1)$$

<p>Решение:</p>

<pre><code class="language-cpp line-numbers">#include &lt;bits/stdc++.h&gt;

using namespace std;

int n;
bool used[1000][1000];
int dst[1000][1000];

//Вспомогательная функция для проверки, можем ли мы пойти в заданную клетку.
bool not_visited(int x, int y) {
    return x >= 0 &amp;&amp; x &lt; n
        &amp;&amp; y >= 0 &amp;&amp; y &lt; n
        &amp;&amp; !used[x][y];
}

int main() {
    int x1, y1, x2, y2;
    cin >> n >> x1 >> y1 >> x2 >> y2;   //n объявлена глобально

    x1--, y1--, x2--, y2--;     //не забываем про сдвиг координат.

    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            dst[i][j] = -1;
        }
    }

    queue&lt;pair&lt;int, int&gt;&gt; q;    //Мы храним уже не номера вершин, а координаты клеток.
    q.push({x1, y1});       //Предполагается использование С++11, в противном случае используйте make_pair
    used[x1][y1] = true;
    dst[x1][y1] = 0;

    while (!q.empty()) {
        pair&lt;int, int&gt; cur = q.front();
        q.pop();

        int cx = cur.first, cy = cur.second;

        //Я очень надеюсь, что в будущем это можно будет делать более адекватным способом (2015).
        if (not_visited(cx + 1, cy + 2)) {
            q.push({cx + 1, cy + 2});
            used[cx + 1][cy + 2] = true;
            dst[cx + 1][cy + 2] = dst[cx][cy] + 1;
        }

        if (not_visited(cx + 1, cy - 2)) {
            q.push({cx + 1, cy - 2});
            used[cx + 1][cy - 2] = true;
            dst[cx + 1][cy - 2] = dst[cx][cy] + 1;
        }

        if (not_visited(cx - 1, cy + 2)) {
            q.push({cx - 1, cy + 2});
            used[cx - 1][cy + 2] = true;
            dst[cx - 1][cy + 2] = dst[cx][cy] + 1;
        }

        if (not_visited(cx - 1, cy - 2)) {
            q.push({cx - 1, cy - 2});
            used[cx - 1][cy - 2] = true;
            dst[cx - 1][cy - 2] = dst[cx][cy] + 1;
        }

        if (not_visited(cx + 2, cy + 1)) {
            q.push({cx + 2, cy + 1});
            used[cx + 2][cy + 1] = true;
            dst[cx + 2][cy + 1] = dst[cx][cy] + 1;
        }

        if (not_visited(cx + 2, cy - 1)) {
            q.push({cx + 2, cy - 1});
            used[cx + 2][cy - 1] = true;
            dst[cx + 2][cy - 1] = dst[cx][cy] + 1;
        }

        if (not_visited(cx - 2, cy + 1)) {
            q.push({cx - 2, cy + 1});
            used[cx - 2][cy + 1] = true;
            dst[cx - 2][cy + 1] = dst[cx][cy] + 1;
        }

        if (not_visited(cx - 2, cy - 1)) {
            q.push({cx - 2, cy - 1});
            used[cx - 2][cy - 1] = true;
            dst[cx - 2][cy - 1] = dst[cx][cy] + 1;
        }
    }

    if (dst[x2][y2] != -1) {
        cout &lt;&lt; dst[x2][y2];
    } else {
        cout &lt;&lt; "Impossible";
    }
}
</code></pre>

<p>Как видите, отличие заключается лишь в том, что вместо перебора соседних вершин
из списка смежности, мы вычисляем их на лету используя возможные ходы фигуры.</p>
