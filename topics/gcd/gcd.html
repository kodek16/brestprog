---
layout: topic
title: НОД. НОК. Алгоритм Евклида
permalink: topics/gcd
---

<h3>Наибольший общий делитель</h3>

<p>Как несложно догадаться, наибольший общий делитель (<em>англ.</em> greatest
common divisor) двух целых чисел &ndash; наибольшее число, на которое делится
каждое из них. Например:</p>

<p style="text-align: center">
$$\gcd(15, 20) = 5$$ <br />
$$\gcd(12, 30) = 6$$
</p>

<p>Сразу заметим важное свойство:</p>

$$\gcd(a, b) = \gcd(b, a)$$

<p>НОД играет большую роль как в математике, так и в программировании, и часто
встречается в задачах на различные темы.</p>

<h3>Алгоритм Евклида</h3>

<p>Алгоритм Евклида &ndash; один из первых алгоритмов в истории, использовался
ещё в Древней Греции, и дошёл до наших дней. В изначальном виде он назывался
"взаимным вычитанием", так как заключался в поочерёдном вычитании меньшего
числа из большего, пока одно из них не станет равным 0. Сегодня чаще всего
вместо вычитания используется взятие остатка от деления, но суть алгоритма
сохранилась.</p>

<p>Алгоритм заключается в построении ряда чисел следующего вида ($$a &gt; b$$):</p>

$$a, b, r_1, r_2, \ldots, r_n$$

<p>Где каждое последующее число является остатком от деления предпредыдущего
на предыдущее:</p>

<table style="margin: auto"><td>
$$r_1 = a \bmod b$$    <br />
$$r_2 = b \bmod r_1$$  <br />
$$\ldots$$ <br />
$$r_n = r_{n - 2} \bmod r_{n - 1}$$
</td></table>

<p>Ряд заканчивается, когда остаток от деления предпоследнего числа на
последнее становится равным 0:</p>

$$r_{n - 1} \bmod r_n = 0$$

<p>В таком случае утверждается, что:</p>

$$\gcd(a, b) = r_n$$

<p>Для доказательства этого утверждения сначала докажем следующее:
наборы общих делителей пары $$(a, b)$$ и пары $$(b, r_1)$$ полностью совпадают.
Рассмотрим произвольный (не обязательно наибольший) общий делитель $$a$$ и $$b$$:</p>

<table style="margin: auto; border: 1px solid black"><td style="padding: 5px">
<p>$$t$$ - общий делитель $$a$$ и $$b$$.</p>
<p>$$r_1 = a \bmod b$$, или $$a = bq + r_1$$.</p>
<p>Докажем, что $$t$$ также является общим делителем $$b$$ и $$r_1$$.</p>
<p>$$b$$ делится на $$t$$ по определению.</p>
<p>$$r_1 = a - bq = t * ({a \over t} - {b \over t} * q)$$, где $${a \over t}$$ и $${b \over t}$$ целые по определению.</p>
<p>Значит, $$r_1$$ также делится на $$t$$, что и требовалось доказать.</p>
</td></table>

<p>Из того, что все общие делители пар $$(a, b)$$ и $$(b, r_1)$$ совпадают,
в частности следует, что $$\gcd(a, b) = \gcd(b, r_1)$$.</p>

<p>Далее по индукции можно доказать следующее:</p>

$$\gcd(a, b) = \gcd(b, r_1) = \gcd(r_1, r_2) = \ldots = \gcd(r_{n - 1}, r_n) = \gcd(r_n, 0)$$

<p>(Нуль в последнем выражении появился из условия $$r_{n - 1} \bmod r_n = 0$$).</p>

<p>Нуль делится на все числа, отличные от нуля, поэтому справедливо следующее
свойство:</p>

$$\gcd(x, 0) = x,\ для\ любого\ x \in \mathbb{N}.$$

<p>Следовательно,</p>

$$\gcd(a, b) = r_n,$$

<p>что и требовалось доказать.</p>

<h3>Варианты реализации алгоритма Евклида на C++</h3>

<p>Существует несколько вариантов реализации алгоритма Евклида, как итеративных
так и рекурсивных. Классическая итеративная реализация (работающая быстрее всех
рекурсивных) выглядит так:</p>

<pre><code class="language-cpp line-numbers">int gcd(int a, int b) {
    if (a &lt; b) {
        swap(a, b);
    }

    while (b) {
        a %= b;
        swap(a, b);
    }

    return a;
}
</code></pre>

<p>Рекурсивно это же можно реализовать так:</p>

<pre><code class="language-cpp line-numbers">int gcd(int a, int b) {
    if (a &lt; b) {
        swap(a, b);
    }

    if (b) {
        return gcd(b, a % b);
    } else {
        return a;
    }
}
</code></pre>

<p>Преимущество рекурсивной реализации заключается в возможности записать её в
очень кратком виде (предполагающим, что $$a > b$$):

<pre><code class="language-cpp line-numbers">int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}
</code></pre>

<p>На практике разница во времени работы итеративного и рекурсивного вариантов
не столь значительна, так что вы можете использовать любой из них.</p>

<h3>Время работы алгоритма Евклида</h3>

<p>Согласно некоторым исследованиям, время работы алгоритма Евклида тесно
связано с числами Фибоначчи. Это выражается, в частности, в том, что два
последовательных числа Фибоначчи &ndash; наихудшие входные данные для алгоритма
Евклида. При $$a = F_n, b = F_{n - 1}$$, алгоритм Евклида совершит ровно
$$n - 2$$ итерации. Отсюда можно выразить асимптотическую сложность алгоритма:
последовательность Фибоначчи возрастает с экспоненциальной скоростью, поэтому
алгоритм Евклида работает за $$O(\log \min(a, b))$$.</p>

<h3>Наименьшее общее кратное</h3>

<p>С понятием НОД связано также понятия наименьшего общего кратного (<em>англ.
</em> least common multiple). Наименьшее общее кратное двух натуральных чисел &ndash;
наименьшее натуральное число, которое делится на каждое из них. Оно обозначается
следующим образом:</p>

$$lcm(a, b)$$

<p>и связано с НОД формулой:</p>

$$lcm(a, b) = {a * b \over \gcd(a, b)}$$

<p>Реализация на C++:</p>

<pre><code class="language-cpp line-numbers">int gcd(int a, int b) {
    return a / gcd(a, b) * b;   //используя форму a * b / gcd(a, b),
                                //можно получить переполнение на этапе a * b,
                                //поэтому следует выполнять деление до умножения
}
</code></pre>

<h3>Взаимнопростые числа</h3>
Числа $$a$$ и $$b$$ называются взаимнопростыми тогда и только тогда, когда они
не имеют общих делителей отличных от $$1$$. То есть в их отношении должно
выполняться условие $$\gcd(a, b) = 1$$.

<h3>НОД и НОК для произвольного количества чисел</h3>

<p>Обе функции легко обобщаются для произвольного числа аргументов
последовательным применением:</p>

$$\gcd(a, b, c, d) = \gcd(\gcd(\gcd(a, b), c), d)$$
$$lcm(a, b, c, d) = lcm(lcm(lcm(a, b), c), d)$$
