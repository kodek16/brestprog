---
layout: topic
title: Проверка графа на наличие циклов
permalink: topics/graphcycles
---

<h3>Постановка задачи</h3>

<p>Для заданного графа нужно ответить, содержит ли он хотя бы один цикл. Стоит
заметить, что от нас не требуется найти <em>все</em> циклы, нужно всего лишь
ответить, существует ли хотя бы один. Задача на поиск всех циклов решается
гораздо сложнее.</p>

<h3>Алгоритм</h3>

<p>Для поиска цикла будем использовать DFS. Для примера разберём такой граф:</p>

<img style="display: block; margin: auto" src="/resources/graph_cycles.png" />

<p>Допустим, мы запустили DFS из вершины 1, и он полностью обошёл граф.
Представим обход этого графа так же, как представляем деревья, по уровням
в зависимости от глубины рекурсии:</p>

<img style="display: block; margin: auto" src="/resources/graph_cycles2.png" />

<p>(Примечание: это только один из возможных вариантов обхода в глубину.)</p>

<p>Как видите по одному из ребёр, входящих в цикл, DFS не спускался: оно
выделено красным цветом. Именно по наличию таких "восходящих" рёбер в графе
можно судить о наличии в нём циклов. При реализации DFS такие рёбра распознать
достаточно легко: они ведут в уже посещённую ($used$) вершину, но не в прямого
предка ($p$).</p>

<h3>Реализация</h3>

<pre><code class="language-cpp line-numbers">#include &lt;bits/stdc++.h&gt;

using namespace std;

vector&lt;int&gt; graph[100000];
bool used[100000];

void dfs(int v, int p = -1) {    //p - прямой предок
    used[v] = true;

    for (int u: graph[v]) {
        if (!used[u]) {
            dfs(u, v);
        } else if (u != p) {
            cout &lt;&lt; "Graph has cycles.";
            exit(0);    //Полностью выйти из программы.
        }
    }
}

int main() {
    //Ввод графа...

    //Проверяем отдельно каждую вершину, так как
    //граф может быть несвязным, но всё равно иметь циклы
    for (int i = 0; i &lt; n; i++) {
        if (!used[i]) {
            dfs(i);
        }
    }

    //Если мы ещё не вышли не вышли из программы, в графе нет циклов.
    cout &lt;&lt; "Graph has no cycles.";
}
</code></pre>

<p>Сложность: $O(N)$</p>
