---
layout: topic
title: Система непересекающихся множеств (DSU)
permalink: topics/dsu
---

<h3>Определение</h3>

<p>Система непересекающихся множеств &ndash; структура данных для эффективной
работы с <em>непересекающимися</em> множествами (каждый элемент принадлежит
только к одному множеству), позволяющий проверять, принадлежат ли два элемента
к одинаковому множеству, и объединять множества.</p>

<p>СНМ часто называют DSU, от <em>англ.</em> Disjoint Set Union, хотя DSU &ndash;
это название только операции объединения (Union). Впрочем, эта аббревиатура
уже устоялась в олимпиадном программировании, поэтому она будет использоваться
далее.</p>

<p>DSU представляет собой набор корневых деревьев (<strong>лес</strong>). Каждое
дерево соответствует определённому множеству. При реализации DSU необходимо
лишь подниматься вверх по деревьям, поэтому достаточно хранить для каждой
вершины только номер её прямого предка. Для этого используется массив $$p$$.</p>

<p>Для описания множества используется номер вершины, являющейся корнем
соответствующего дерева. Поэтому для определения, принадлежат ли два элемента
к одному и тому же множеству, для каждого элемента нужно найти корень
соответствующего дерева (поднимаясь вверх пока это возможно) и сравнить эти
корни.</p>

<p>Объединяются множества элементарно. Пусть нам нужно объединить множества
с корнями $$a$$ и $$b$$. Просто присвоим $$p[a] = b$$, тем самым подвесив всё дерево
$$a$$ к корню дерева $$b$$.</p>

<h3>Реализация: наивный вариант</h3>

<pre><code class="language-cpp line-numbers">int p[100000];

void init_dsu() {
    for (int i = 0; i &lt; 100000; i++) {
        p[i] = i;  //каждая вершина изначально является корнем отдельного дерева
    }
}

int get_root(int v) {
    if (p[v] == -1) {
        return v;
    } else {
        return get_root(p[v]);
    }
}

//a и b - любые вершины в деревьях
//возвращаемое значение обозначает, находились ли до вызова функции a и b в разных деревьях
bool merge(int a, int b) {
    int ra = get_root(a), rb = get_root(b);

    if (ra == rb) {
        return false;
    } else {
        p[ra] = rb;
        return true;
    }
}
</code></pre>

<p>При такой реализации создаётся 100000 вершин, каждая из которых является
отдельным деревом.</p>

<h3>Оптимизация 1: ранги вершин</h3>

<p>Можно заметить, что при такой реализации при постепенном объединении
деревьев глубина будет расти вплоть до $$N$$, так как деревья вырождаются
в связные списки. Разумеется, такая глубина не позволяет эффективно
использовать структуру данных. Поэтому нужно применять дополнительные
оптимизации, в первую очередь, при объединении деревьев.</p>

<p>Одна из самых простых и эффективных оптимизаций &ndash; поддерживать для
всех деревьев текущую глубину, и при объединении подвешивать дерево
с меньшей глубиной к корню дерева с большей глубиной. Глубина дерева
данной вершины поддерживается в виде её <strong>ранга</strong>. Строго
говоря, при применении дополнительной оптимизации (описанной ниже), ранг
вершины описывают не точную глубину дерева, а её верхнюю границу, но
это не играет роли.</p>

<h3>Реализация: ранги вершин</h3>

<pre><code class="language-cpp line-numbers">int p[100000];
int rk[100000];   //имя rank уже используется библиотекой

void init_dsu() {
    for (int i = 0; i &lt; 100000; i++) {
        p[i] = i;
        rk[i] = 1;    //Начальное значение не играет роли.
    }
}

int get_root(int v) {
    if (p[v] == -1) {
        return v;
    } else {
        return get_root(p[v]);
    }
}

bool merge(int a, int b) {
    int ra = get_root(a), rb = get_root(b);

    if (ra == rb) {
        return false;
    } else {
        if (rk[ra] &lt; rk[rb]) {
            p[ra] = rb;
        } else if (rk[rb] &lt; rk[ra]) {
            p[rb] = ra;
        } else {            //Если оба дерева имеют одинаковую глубину,
            p[ra] = rb;     //неважно, какое из них подвешивать.
            rk[rb]++;     //При этом глубина нового дерева увеличится на 1.
        }

        return true;
    }
}
</code></pre>

<h3>Оптимизация 2: сжатие путей</h3>

<p>С помощью рангов максимальная глубина дерева (а значит и сложность операций)
понизилась до $$\log N$$. Этого уже может быть достаточно, но существует ещё одна
невероятно простая оптимизация (для её применения достаточно добавить в
предущий код пять символов). Эта оптимизация заключается в сжатии путей
при поиске корня.</p>

<p>Идея заключается в следующем: при поиске корня заданной вершины будем
переподвешивать её за найденный корень. Допустим, мы вызвали функцию
<code>get_root</code> для вершины, которую отделяют от корня дерева пять
других вершин. Рекурсивный вызов <code>get_root</code> обойдёт каждую
из них, и найдёт корень. На выходе из каждого рекурсивного вызова просто
переподвесим текущую вершину за только что найденный корень. Таким образом,
все пять вершин теперь будут подвешены напрямую к корню.</p>

<h3>Реализация: сжатие путей</h3>

<pre><code class="language-cpp line-numbers">int p[100000];
int rk[100000];

void init_dsu() {
    for (int i = 0; i &lt; 100000; i++) {
        p[i] = i;
        rk[i] = 1;
    }
}

int get_root(int v) {
    if (p[v] == -1) {
        return v;
    } else {
        return p[v] = get_root(p[v]);   //На выходе из рекурсии переподвешиваем v
    }
}

bool merge(int a, int b) {
    int ra = get_root(a), rb = get_root(b);

    if (ra == rb) {
        return false;
    } else {
        if (rk[ra] &lt; rk[rb]) {
            p[ra] = rb;
        } else if (rk[rb] &lt; rk[ra]) {
            p[rb] = ra;
        } else {
            p[ra] = rb;
            rk[rb]++;
        }

        return true;
    }
}
</code></pre>

<p>При такой реализации <em>амортизированная</em> сложность каждой операции
равна $$O(\alpha(n))$$, где $$\alpha(n)$$ &ndash; обратная функция Аккермана,
значение которой не превышает $$5$$ для всех разумных $$n$$. Другими словами,
амортизированная сложность каждой операции примерно равна $$O(1)$$.</p>

<p>Под амортизированной сложностью подразумевают отношение времени работы
алгоритма ко входным данным в <em>большинстве</em> случаев (не учитываются,
в частности, сжатия путей, которые происходят достаточно редко).</p>

<h3>Применение DSU</h3>

<p>Чаще всего DSU используется вместе с алгоритмом Крускала для нахождения
минимального остовного дерева графа.</p>
