---
layout: topic
title: Битовые маски. Динамическое программирование по маскам
permalink: topics/bitmasks
---

<h3>Битовые маски</h3>

<p>Как известно, числа в памяти компьютера представляются в двоичной системе
счисления в виде последовательности битов. Один бит может иметь значение
$$0$$ или $$1$$. Можно провести аналогию между битами и значениями типа
<code>bool</code>: $$0$$ обозначает <code>false</code>, а $$1$$ &ndash;
<code>true</code>. По такой аналогии число (последовательность битов) можно
представить как массив значений <code>bool</code>. Например, тип <code>int</code>
может обозначать массив из $$32$$ значений <code>bool</code>, а <code>long long</code>
&ndash; из $$64$$.</p>

<p>Чаще всего массивы <code>bool</code> небольшого размера испольуются для обозначения
некоторого подмножества объектов, выбранного из множества. Например, для обозначения
элементов с индексами $$1$$ и $$4$$ (0-индексация), выбранных из множества из пяти
элементов используется массив $$\{false, true, false, false, true\}$$, или
$$\{0, 1, 0, 0, 1\}$$. Его можно представить в виде значения типа <code>int</code>:
$$10010_2$$ (индексация обычно начинается с младших битов числа, записываемых справа).</p>


<p>При интерпретации такого значения как обычного числа, оно будет равно
$$10010_2 = 18_{10}$$. Но при интерпретации его как массива логических значений
(битов), оно будет обозначать $$\{0, 1, 0, 0, 1\}$$. С точки зрения C++ эти два
значения равносильны, и то, является ли значение типа <code>int</code> числом,
или массивом <code>bool</code>, зависит только от контекста, в котором оно
используется.</p>

<p>При использовании значений типа <code>int</code> или <code>long long</code>
как массивов из <code>bool</code>, такие значения называются <strong>битовыми
масками</strong>.</p>

<h3>Операции с битовыми масками</h3>

<p>Для работы с масками используются побитовые операции $$and, or, xor$$, и
битовые сдвиги.</p>

<p>Пусть две маски обозначают два множества элементов, и нам нужно получить
маску, содержащую элементы, входящие в оба множества (<em>пересечение</em>
множеств). В новой маске <code>true</code> должны находится только в тех
позициях, где в обеих масках находились <code>true</code>. Несложно заметить,
что такое описание соответствует побитовой операции $$and$$:</p>

<img style="display: block; margin: auto; padding-bottom: 20px" src="/resources/bit_and.png" />

<code style="display: block; text-align: center" class="prettyprint">
int c = a &amp; b;  //маска c равна пересечению масок a и b
</code>

<p>Другой распространённой операцией является <em>объединение</em> множеств.
При объединении в новой маске <code>true</code> должны находиться в тех
позициях, в которых в хотя бы одной из масок находилось <code>true</code>.
Такое описание соответствует побитовой операции $$or$$:</p>

<img style="display: block; margin: auto; padding-bottom: 20px" src="/resources/bit_or.png" />

<code style="display: block; text-align: center" class="prettyprint">
int c = a | b;  //маска c равна объединению масок a и b
</code>

<p>Для получения значения индивидуального бита используется комбинация
битового сдвига вправо и операции $$and$$. Сначала нам нужно сдвинуть
биты маски так, чтобы нужный бит оказался самым младшим (находился справа).
Затем нам нужно откинуть все остальные биты маски. Реализуется это следующим
образом:</p>

<img style="display: block; margin: auto; padding-bottom: 20px" src="/resources/bit_get.png" />

<code style="display: block; text-align: center" class="prettyprint">
int bit = (a >> idx) &amp; 1;  //bit равен значению idx-го бита в маске a
</code>

<p>Для установки значения определённого бита маски в <code>true</code> мы
должны применить к нему операцию $$or\ true$$. Реализуется это так (ко
всем остальным битам применяется $$or\ false$$, не имеющая никакого эффекта):</p>

<img style="display: block; margin: auto; padding-bottom: 20px" src="/resources/bit_set_true.png" />

<code style="display: block; text-align: center" class="prettyprint">
int b = a | (1 &lt;&lt; idx);  //маска b - копия маски a, в которой idx-ый бит установлен в true
</code>

<p>Для изменения значения определённого бита на противоположное, нужно
применить к нему операцию $$xor\ true$$. Ко всем остальным битам применяется
$$xor\ false$$, также не имеющая никакого эффекта:</p>

<img style="display: block; margin: auto; padding-bottom: 20px" src="/resources/bit_invert.png" />

<code style="display: block; text-align: center" class="prettyprint">
int b = a ^ (1 &lt;&lt; idx);  //маска b - копия маски a с противоположным значением idx-го бита
</code>

<p>Это самые распространённые операции, выполняемые с масками. Существует
множество других, здесь не приведённых, но все они основаны на $$and, or, xor$$,
и сдвигах.</p>

<h3>Динамическое программирование по подмножествам</h3>

<p>Битовые маски часто используются как параметры для динамического
программирования. Такой вид ДП называется ДП по маскам, или ДП по подмножествам.</p>

<p>Классической задачей на ДП по подмножествам является широко известная
<strong>задача о коммивояжёре</strong> (<em>англ.</em> TSP - Travelling
Salesman Problem). В общем виде она ставится следующим образом:</p>

<p style="display: block; margin: auto; width: 60%">
Существует $$N$$ городов, между некоторыми из которых есть дороги. Требуется
обойти все города, вернувшись в первый, так, чтобы длина пути была минимальной.
</p>

<p>Эта задача является классической NP-полной задачей, и ДП по подмножествам
со сложностью порядка $$O(2^N * N^2)$$ &ndash; её оптимальное решение.</p>

<p>Для простоты реализации примем, что города являются точками на геометрической
плоскости, и между каждой парой есть путь, длина которого равна расстоянию между
точками.</p>

<p>Обозначим за $$dp[mask][i]$$ &ndash; длину кратчайшего пути, начинающегося
в вершине $$0$$, проходящего через все вершины $$mask$$, и заканчивающегося
в вершине $$i$$ ($$0 \in mask; i \in mask$$). Начальные
значения ДП можно записать следующим образом:</p>

$$dp[mask][i] = \infty \\
dp[\{0\}][0] = 0$$

<p>Запись $$\{0\}$$ обозначает маску, обозначающую множество, состоящее только из
элемента $$0$$.</p>

<p>Формула перехода для ДП выглядит так:</p>

$$dp[mask][i] = \min_{\substack{j\ \in\ mask \backslash i}} (dp[mask \backslash i][j] + dst(j, i))$$

<p>Запись $$mask \backslash i$$ обозначает множество $$mask$$ без элемента $$i$$.</p>

<p>Формула перехода обозначает следующее: чтобы попасть в вершину $$i$$, нужно
перейти в неё из какой-либо другой вершины $$j$$, также входящей в $$mask$$. Из
всех таких вершин нужно выбрать такую, что общая длина пути в $$i$$ будет
наименьшей. Общая длина пути рассчитывается как длина пути в $$j$$
($$dp[mask \backslash i][j]$$) плюс длина пути из $$j$$ в $$i$$ ($$dst(j, i)$$).</p>

<p>Чтобы найти минимальную длину цикла из всех вершин, нужно перебрать вершину
$$i$$, и выбрать такую, что длина цикла $$0 - \ldots - i - 0$$ минимальна. Длина
такого цикла вычисляется по формуле $$dp[\mathbb{V}][i] + dst(i, 0)$$:</p>

$$ans = \min\limits_{i \in \mathbb{V}} (dp[\mathbb{V}][i] + dst(i, 0))$$

<p>Запись $$\mathbb{V}$$ обозначает множество всех вершин.</p>

<p>Может показаться, что порядок пересчёта такого ДП будет достаточно сложным.
На самом деле это не так: заметьте что для пересчета $$dp[mask][i]$$ нам нужно,
чтобы уже был посчитан ответ для маски $$mask \backslash i$$. Можно легко доказать,
что в численном выражении $$mask \backslash i$$ будет гарантированно меньше $$mask$$,
так как на некоторой позиции в $$mask$$ будет находиться бит $$1$$, а в
$$mask \backslash i$$ бит $$0$$. Значит, можно просто пересчитывать ДП в порядке
возрастания значения $$mask$$ в численном выражении.</p>

<h3>Реализация решения задачи о коммивояжёре</h3>

<pre><code class="language-cpp line-numbers">#include &lt;bits/stdc++.h&gt;

using namespace std;

const double INF = 1e9 + 7;     //бесконечность

double x[20], y[20];    //координаты городов.

//Заметим, что для N элементов существует 2^N возможных подмножеств (масок)
//значением от 0 до 2^N - 1.
//Можно просто возвести 2 в произвольную степень с помощью битового сдвига:
//2^N = 1 &lt;&lt; N
double dp[1 &lt;&lt; 20][20];

//Расстояние между городами a и b
double dst(int a, int b) {
    double dx = x[a] - x[b], dy = y[a] - y[b];
    return sqrt(dx * dx + dy * dy);
}

int main() {
    int n;
    cin >> n;

    for (int i = 0; i &lt; n; i++) {
        cin >> x[i] >> y[i];
    }

    for (int mask = 0; mask &lt; (1 &lt;&lt; n); mask++) {
        for (int i = 0; i &lt; n; i++) {
            dp[mask][i] = INF;
        }
    }

    dp[1][0] = 0;   //Маска 1 содержит только нулевой элемент.

    for (int mask = 2; mask &lt; (1 &lt;&lt; n); mask++) {
        for (int i = 0; i &lt; n; i++) {
            if ((mask >> i) &amp; 1) {      //Если mask содержит i
                int mask_without_i = mask ^ (1 &lt;&lt; i);

                for (int j = 0; j &lt; n; j++) {
                    if (j != i &amp;&amp; ((mask >> j) &amp; 1)) {  //Если j != i и mask содержит j
                        dp[mask][i] = min(dp[mask][i], dp[mask_without_i][j] + dst(j, i));
                    }
                }
            }
        }
    }

    double ans = INF;
    int mask_all = (1 &lt;&lt; n) - 1;  //маска, содержащая все элементы

    for (int i = 0; i &lt; n; i++) {
        ans = min(ans, dp[mask_all][i] + dst(i, 0));
    }

    cout &lt;&lt; ans &lt;&lt; endl;
}
</code></pre>
