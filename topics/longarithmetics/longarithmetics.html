---
layout: topic
title: Длинная арифметика
permalink: topics/longarithmetics
---

<h3>Определение</h3>

<p>Длинная арифметика &ndash; набор алгоритмов для поразрядной работы с числами
произвольной длины. Она применяется как с относительно небольшими числами,
превышающими ограничения типа <code>long long</code> в несколько раз, так и с
по-настоящему большими числами (чаще всего до $$10^{100000}$$).</p>

<p>Для работы с "длинными" числами их разбивают на <em>разряды</em>. Размер
разряда может быть произвольным, но чаще всего используются следующие:</p>

<ul>
    <li>$$10$$ &ndash; по аналогии с цифрами числа в десятичной системе, для простоты
    понимания и отладки.</li>

    <li>$$10^4$$ &ndash; набольшая степень десяти, квадрат которой не превышает
    ограничения типа <code>int</code>. Используется для максимальной эффективности
    при хранении разрядов как чисел типа <code>int</code>.

    <li>$$10^9$$ &ndash; аналогично предыдущему пункту, но для типа
    <code>long long</code>. Позволяет достичь максимально возможной эффективности.</li>
</ul>

<p>(Ограничения на квадрат размера разряда связаны с необходимостью перемножать между
собой разряды. Если квадрат разряда превышает ограничение своего типа, при умножении
возможны переполнения.)</p>

<p>В большинстве реализаций разряды хранятся в порядке, обратным привычному для
упрощения работы с ними. Например число $$578002300$$ при размере разряда $$10^4$$
представляется следующим массивом:</p>

$$\{2300, 7800, 5\}$$

<p>Количество разрядов числа может быть как ограничено, так и не ограничено, в
зависимости от типа используемого контейнера: массива константной длины или
вектора.</p>

<h3>Реализация</h3>

<p>Далее будет приведена реализация длинной арифметики, использующая размер
разряда $$10^9$$, и массив константой длины $$10$$ для хранения разрядов. Таким
образом, эта реализация позволяет быстро работать с числами до $$10^{90}$$.</p>

<p>Реализация будет приведена в виде структуры <code>bigint</code> с перегруженными
математическими операторами. Предполагается владение соответствующим материалом по
C++.</p>

<p>Начнём с основных элементов структуры:</p>

<pre><code class="language-cpp line-numbers">struct bigint {

    static const long long BASE = 1e9;     //размер разряда
    static const long long SIZE = 10;      //количество вмещаемых разрядов

    long long digits[SIZE];

    bigint() {                                  //стандартный конструктор
        for (int i = 0; i &lt; SIZE; i++) {
            digits[i] = 0;
        }
    }

    bigint(long long x) {                       //конструктор для преобразования обычного числа в длинное
        for (int i = 0; i &lt; SIZE; i++) {
            digits[i] = 0;
        }

        int next = 0;
        while (x) {
            digits[next++] = x % BASE;
            x /= BASE;
        }
    }

    bigint(const bigint&amp; other) {           //конструктор копирования
        for (int i = 0; i &lt; SIZE; i++) {
            digits[i] = other.digits[i];
        }
    }

    bigint&amp; operator=(const bigint&amp; other) {    //оператор присваивания
        for (int i = 0; i &lt; SIZE; i++) {
            digits[i] = other.digits[i];
        }

        return *this;
    }
</code></pre>

<h3>Сложение</h3>

<p>Длинную арифметику часто сравнивают с детским вычислением "в столбик". Это
достаточно справедливо, так как оба методы основаны на поразрядных операциях.
Если вы умеете складывать в столбик, то реализация длинного сложения не должна
вызвать у вас трудностей:</p>

<pre><code class="language-cpp line-numbers">    void operator+=(const bigint&amp; other) {
        for (int i = 0; i &lt; SIZE; i++) {        //сначала сложим числа поразрядно,
            digits[i] += other.digits[i];       //игнорируя переполнения
        }

        for (int i = 0; i &lt; SIZE - 1; i++) {    //а затем поочередно выполним переносы
            if (digits[i] >= BASE) {            //для каждого разряда
                digits[i] -= BASE;
                digits[i + 1]++;
            }
        }
    }

    bigint operator+(const bigint&amp; other) {
        bigint n(*this);
        n += other;
        return n;
    }

    bigint&amp; operator++() {
        *this += 1;
        return *this;
    }
</code></pre>

<h3>Вычитание</h3>

<p>Вычитание реализуется симметрично сложению:</p>

<pre><code class="language-cpp line-numbers">    void operator-=(const bigint&amp; other) {
        for (int i = 0; i &lt; SIZE; i++) {
            digits[i] -= other.digits[i];
        }

        for (int i = 0; i &lt; SIZE - 1; i++) {
            if (digits[i] &lt; 0) {
                digits[i] += BASE;
                digits[i + 1]--;
            }
        }
    }

    bigint operator-(const bigint&amp; other) {
        bigint n(*this);
        n -= other;
        return n;
    }

    bigint&amp; operator--() {
        *this -= 1;
        return *this;
    }
</code></pre>

<h3>Умножение</h3>

<p>Реализация умножения немного отличается от алгоритма умножения в столбик,
но принцип сохраняется: перемножим каждый разряд одного числа на каждый разряд
другого. При умножении разряда $$i$$ на разряд $$j$$ добавим результат к разряду
$$i + j$$ произведения (0-индексация). После этого выполним переносы аналогично
сложению:</p>

<pre><code class="language-cpp line-numbers">    void operator*=(const bigint&amp; other) {
        *this = *this * other;
    }

    bigint operator*(const bigint&amp; other) {
        bigint result;

        for (int i = 0; i &lt; SIZE; i++) {             //игнорируем переполнения всего числа
            for (int j = 0; j &lt; SIZE - i; j++) {     //(откидываем разряды больше SIZE)
                result.digits[i + j] += digits[i] * other.digits[j];
            }
        }

        //Не забываем, что мы могли переполнить размер разряда более, чем в два раза.
        //Для переноса воспользуемся делением.
        for (int i = 0; i &lt; SIZE - 1; i++) {
            result.digits[i + 1] += result.digits[i] / BASE;
            result.digits[i] %= BASE;
        }

        return result;
    }
</code></pre>

<p>Такой алгоритм легко реализуется, но имеет сложность $$O(N^2)$$ ($$N$$ &ndash;
количество разрядов). Более эффективный алгоритм (алгоритм Карацубы)
позволяет перемножать длинные числа за $$O(N^{1.58})$$, но вам он вряд ли
понадобится.</p>

<h3>Деление на короткое</h3>

<p>В отличие от других арифметических операций, деление длинного числа на
другое длинное реализуется достаточно сложно, и в школьных задачах вам
вряд ли придётся им пользоваться.</p>

<p>Деление на короткое число (меньше размера разряда), напротив, реализуется
очень просто. Просто делим по очереди каждый разряд длинного числа на короткое,
сохраняем целую часть, а остаток переносим в предыдущий (младший) разряд:</p>

<pre><code class="language-cpp line-numbers">    void operator/=(long long x) {
        for (int i = SIZE - 1; i >= 0; i--) {
            if (i) {
                digits[i - 1] += (digits[i] % x) * BASE;
            }

            digits[i] /= x;
        }
    }

    bigint operator/(long long x) {
        bigint n(*this);
        n /= x;
        return n;
    }
</code></pre>

<h3>Вывод длинного числа</h3>

<p>Реализуем также вспомогательную функцию, позволяющую нам выводить длинные
числа на экран так же просто, как и короткие.</p>

<pre><code class="language-cpp line-numbers">ostream&amp; operator&lt;&lt;(ostream&amp; out, const bigint&amp; num) {
    string result;

    char buffer[10];

    for (int i = bigint::SIZE - 1; i >= 0; i--) {
        sprintf(buffer, "%09d", num.digits[i]);
        result += buffer;
    }

    int first_idx = result.find_first_not_of('0');
    if (first_idx == string::npos) {
        out &lt;&lt; "0";
    } else {
        out &lt;&lt; result.substr(first_idx);
    }

    return out;
}
</code></pre>

<h3>Полный код структуры</h3>

<pre><code class="language-cpp line-numbers">struct bigint {

    static const long long BASE = 1e9;
    static const long long SIZE = 10;

    long long digits[SIZE];

    bigint() {
        for (int i = 0; i &lt; SIZE; i++) {
            digits[i] = 0;
        }
    }

    bigint(long long x) {
        for (int i = 0; i &lt; SIZE; i++) {
            digits[i] = 0;
        }

        int next = 0;
        while (x) {
            digits[next++] = x % BASE;
            x /= BASE;
        }
    }

    bigint(const bigint&amp; other) {
        for (int i = 0; i &lt; SIZE; i++) {
            digits[i] = other.digits[i];
        }
    }

    bigint&amp; operator=(const bigint&amp; other) {
        for (int i = 0; i &lt; SIZE; i++) {
            digits[i] = other.digits[i];
        }

        return *this;
    }

    void operator+=(const bigint&amp; other) {
        for (int i = 0; i &lt; SIZE; i++) {
            digits[i] += other.digits[i];
        }

        for (int i = 0; i &lt; SIZE - 1; i++) {
            if (digits[i] >= BASE) {
                digits[i] -= BASE;
                digits[i + 1]++;
            }
        }
    }

    bigint operator+(const bigint&amp; other) {
        bigint n(*this);
        n += other;
        return n;
    }

    bigint&amp; operator++() {
        *this += 1;
        return *this;
    }

    void operator-=(const bigint&amp; other) {
        for (int i = 0; i &lt; SIZE; i++) {
            digits[i] -= other.digits[i];
        }

        for (int i = 0; i &lt; SIZE - 1; i++) {
            if (digits[i] &lt; 0) {
                digits[i] += BASE;
                digits[i + 1]--;
            }
        }
    }

    bigint operator-(const bigint&amp; other) {
        bigint n(*this);
        n -= other;
        return n;
    }

    bigint&amp; operator--() {
        *this -= 1;
        return *this;
    }

    void operator*=(const bigint&amp; other) {
        *this = *this * other;
    }

    bigint operator*(const bigint&amp; other) {
        bigint result;

        for (int i = 0; i &lt; SIZE; i++) {
            for (int j = 0; j &lt; SIZE - i; j++) {
                result.digits[i + j] += digits[i] * other.digits[j];
            }
        }

        for (int i = 0; i &lt; SIZE - 1; i++) {
            result.digits[i + 1] += result.digits[i] / BASE;
            result.digits[i] %= BASE;
        }

        return result;
    }

    void operator/=(long long x) {
        for (int i = SIZE - 1; i >= 0; i--) {
            if (i) {
                digits[i - 1] += (digits[i] % x) * BASE;
            }

            digits[i] /= x;
        }
    }

    bigint operator/(long long x) {
        bigint n(*this);
        n /= x;
        return n;
    }
};

ostream&amp; operator&lt;&lt;(ostream&amp; out, const bigint&amp; num) {
    string result;

    char buffer[10];

    for (int i = bigint::SIZE - 1; i >= 0; i--) {
        sprintf(buffer, "%09d", num.digits[i]);
        result += buffer;
    }

    int first_idx = result.find_first_not_of('0');
    if (first_idx == string::npos) {
        out &lt;&lt; "0";
    } else {
        out &lt;&lt; result.substr(first_idx);
    }

    return out;
}
</code></pre>

<p>Разумеется, если в задаче требуются не все операции, можно реализовывать
только некоторые из них.</p>

<h3>Длинная арифметика в разных языках программирования</h3>

<p>В последнее время на олимпиадах длинная арифметика встречается всё реже и
реже, и есть вероятность, что скоро она исчезнет насовсем. Главным образом
это связано с постепенным включением в списки допустимых языков Java и Python,
в которых длинная арифметика встроена в стандартную библиотеку. Из-за этого
необходимость реализовывать её самостоятельно полностью отпадает. Для уравнивания
участников, использующих C++ с участниками, использующими Java и Python,
составители задач стараются избегать задач на банальные длинные арифметические
операции. Хотя сама концепция длинных чисел всё ещё встречается, задачи имеют
несколько другой вид.</p>
