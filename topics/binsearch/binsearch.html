---
layout: topic
title: Бинарный поиск
permalink: topics/binsearch
---

<h3>Определение</h3>

<p>Пусть задана монотонная (возрастающая или убывающая на всей области
определения) функция $f(x)$, а также некоторое значение $y$. Бинарный,
или двоичный, поиск &ndash; алгоритм, позволяющий за время $O(\log N)$ найти
такое значение $x$, что $f(x) = y$.</p>

<h3>Алгоритм</h3>
<p>Бинарный поиск &ndash; один из самых простых алгоритмов. Его идея заключается
в поддерживании некоторого промежутка значений $x$, который гарантированно
содержит искомое значение, и постепенном его сужении до одного элемента (в
случае дискретной функции) или допустимой погрешности (в случае непрерывной
функции). Сужение выполняется следующим образом:</p>

<ul>
    <li>Текущие границы отрезка &ndash; $[L;R]$.</li>
    <li>Определим $M$ как середину отрезка: $M = {L + R \over 2}$.</li>
    <li>Найдём значение функции $f(M)$.</li>
    <li>Сравним это значение с $y$:
        <ul>
            <li>$f(M) &lt; y$: из условия монотонности функции следует, что $M &lt; x$, сужаем отрезок до $(M;R]$.</li>
            <li>$f(M) &gt; y$: из условия монотонности функции следует, что $M &gt; x$, сужаем отрезок до $[L;M)$.</li>
            <li>$f(M) = y$: $M$ - ответ.</li>
        </ul>
    </li>
</ul>

<p>(Здесь и далее предполагается, что функция возрастающая. Для убывающей функции
нужно "развернуть" знаки в некоторых местах).</p>

<p>Стоит заметить, что в некоторых случаях могут существовать несколько
значений $x$, таких что $f(x) = y$. В таком случае обычная реализация бинарного
поиска найдёт произвольное $x$, удовлетворяющее условию. Для определения границ
промежутка искомых значений $x$ нужно пользоваться модифицированным алгоритмом,
ищущим первое значение $x$, такое что $f(x) = y$ и первое значение $x$, такое
что $f(x) > y$. Этого мы ещё коснёмся в разделе реализаций бинарного поиска в
стандартной библиотеке C++.</p>

<h3>Реализация для непрерывной функции на C++</h3>

<p>Для этого примера в качестве функции будем использовать возведение в квадрат:
$f(x) = x^2$. Нам нужно для заданного $y$ найти такое $x$, что $x^2 = y$. Можно
заметить, что это есть не что иное, как квадратный корень из $y$.</p>

<pre><code class="language-cpp line-numbers">double binsearch_sqrt(double y) {
    double l = 0, r = 1e9;      //изначальные границы выбираются исходя из
                                //ограничений на данные в конкретной задаче

    while (r - l > 1e-6) {      //допустимая погрешность: 10^-6
        double m = (l + r) / 2;
        double cur = m * m;

        if (cur &lt; y) {
            l = m;
        } else if (cur &gt; y) {
            r = m;
        } else {
            return m;
        }
    }

    return l;   //l и r практически равны, поэтому неважно,
                //что из них считать ответом.
}
</code></pre>

<h3>Реализация для отсортированного массива как дискретной функции на C++</h3>
<p>Самый распространённый пример бинарного поиска по дискретной функции &ndash;
поиск элемента в отсортированном массиве. Функцию можно записать в виде
$f(x) = a_x$, или $f(x) = a[x]$, где $a$ - отсортированный массив. Другими
словами, бинарный поиск по массиву позволяет найти индекс элемента с заданным
значением.</p>

<pre><code class="language-cpp line-numbers">int binsearch_array(vector&lt;int&gt;&amp; a, int val) {
    int l = 0, r = a.size() - 1;

    while (r &gt; l) {
        int m = (l + r) / 2;    //целочисленное деление!

        if (a[m] &lt; val) {
            l = m + 1;
        } else if (a[m] &gt; val) {
            r = m - 1;
        } else {
            return m;
        }
    }

    //l == r == искомый индекс

    //Если искомого элемента не было в массиве,
    //бинарный поиск найдёт следующий после него элемент.
    //Чтобы распознать этот случай, мы используем дополнительное сравнение.
    if (a[l] == val) {
        return l;
    } else {
        return -1;
    }
}
</code></pre>

<p>С дискретными функциями связано несколько тонких моментов, часто приводящих к
ошибкам, вызывающим зацикливание алгоритма. А именно: возможность использования
открытых или закрытых границ (включающих или исключающих элементы $L$ и $R$), и
целочисленного деления на два при поиске среднего элемента. Чтобы избежать ошибок,
нужно следовать одному простому правилу: новые границы всегда должны включать
элемент $M + 1$ или $M - 1$, но не включать элемент $M$. При выполнении этого
условия бинарный поиск будет работать корректно.</p>

<h3>Реализации бинарного поиска в стандартной библиотеке C++</h3>

<p>В стандартной библиотеке C++ содержатся две основные функции реализующие бинарный
поиск на отсортированном массиве. Их определения:</p>

<pre><code class="language-cpp line-numbers">//параметр value должен иметь тип, на который указывают итераторы.

//возвращает итератор на первый элемент, больший либо равный value
iterator std::lower_bound(iterator begin, iterator end, int value);

//возвращает итератор на первый элемент, строго больший value
iterator std::upper_bound(iterator begin, iterator end, int value);
</code></pre>

<p>Обе эти функции предполагают, что отрезок $[begin;end)$ отсортирован по
стандартному компаратору, в противном случае их поведение не определено.
Для нахождения самого элемента обычно используется функция std::lower_bound.
При наличии элемента, она вернёт итератор на него, а при отсутствии &ndash;
на следующий в порядке сортировки. Если value больше всех элементов
промежутка, функция вернёт итератор end.</p>

<p>Функция std::upper_bound используется в особых ситуациях, когда нужно найти
положение первого элемента, больше заданного.</p>

<p>Возвращаясь к ситуации наличия нескольких искомых элементов в массиве, с помощью
этих функций искомый промежуток можно записать следующим образом:</p>

<p style="text-align: center">$[lower\_bound(x); upper\_bound(x))$</p>

<p>Для бинарного поиска по массиву, отсортированному по собственному компаратору
вы можете воспользоваться расширенной формой функций:</p>

<pre><code class="language-cpp line-numbers">iterator lower_bound(iterator begin, iterator end, int value, comparator comp);
iterator upper_bound(iterator begin, iterator end, int value, comparator comp);
</code></pre>

<p>Вы также можете осуществлять бинарный поиск по библиотечным классам std::set и
std::map. Для этого используйте методы классов:</p>

<pre><code class="language-cpp line-numbers">set&lt;int&gt; s;
/...
set&lt;int&gt;::iterator it = s.lower_bound(k);

map&lt;int, string&gt; m;
/...
map&lt;int, string&gt;::iterator it = m.lower_bound(k);     //бинарный поиск для std::map ведётся по ключам
</code></pre>

<h3>Бинарный поиск по ответу</h3>

<p>Бинарный поиск по ответу &ndash; распространённый подход при решении задач.
Часто применяется в задачах и подзадачах вида "найдите максимально возможное
количество чего-либо при котором выполняются определённые условия". Бинарный
поиск по ответу в таких задачах можно применять, когда выполняются следующие
условия:</p>

<ul>
    <li>Если возможен ответ $N$, то гарантированно возможен и ответ $N − 1$.</li>
    <li>Если невозможен ответ $N$, то гарантированно невозможен и ответ $N + 1$.</li>
</ul>

<p>В качестве примера рассмотрим следующую задачу: <a href="http://codeforces.com/contest/371/problem/C">CF 218 Div2 C. Гамбургеры</a></p>
<p>Параметр, по которому мы выполняем бинарный поиск &ndash; количество
гамбургеров, которые Поликарп может приготовить. Реализуем соотвествующие
функции:</p>

<pre><code class="language-cpp line-numbers">//Считаем, что входные данные уже введены.
long long nb, ns, nc;
long long pb, ps, pc;
long long r;

//Количество необходимых кусков хлеба, колбасы и сыра для одного гамбургера.
//Рассчитывается из строки рецепта.
long long tb, ts, tc;

//Возможно ли приготовить h гамбургеров.
bool possible(long long h) {
    long long cost_b = max(0ll, (tb * h - nb) * pb);
    long long cost_s = max(0ll, (ts * h - ns) * ps);
    long long cost_c = max(0ll, (tc * h - nc) * pc);

    return cost_b + cost_s + cost_c &lt;= r;
}

//Можно заметить, что это не стандартный бинарный поиск
//по элементу, а поиск первого "невозможного" количества
//гамбургеров (аналог std::upper_bound).
//В реализации таких функций часто допускаются ошибки
//в строках подобных 32 и 34, но они быстро выявляются и
//исправляются тестированием на сэмплах.
long long max_possible() {
    long long l = 0, r = 1e14;

    while (l &lt; r) {
        long long m = (l + r) / 2;

        if (possible(m)) {
            l = m + 1;
        } else {
            r = m;
        }
    }

    return l - 1;   //l == r == первое "невозможное" количество
}
</code></pre>

<p><a href="http://codeforces.com/contest/371/submission/12605708">Полное решение этой задачи.</a></p>
