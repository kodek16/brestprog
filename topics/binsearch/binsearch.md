---
layout: topic
title: Бинарный поиск
permalink: topics/binsearch
---

### Определение

Пусть задана монотонная (возрастающая или убывающая на всей области
определения) функция $$f(x)$$, а также некоторое значение $$y$$. Бинарный,
или двоичный, поиск - алгоритм, позволяющий за время $$O(\log N)$$ найти
такое значение $$x$$, что $$f(x) = y$$.

### Алгоритм
Бинарный поиск - один из самых простых алгоритмов. Его идея заключается
в поддерживании некоторого промежутка значений $$x$$, который гарантированно
содержит искомое значение, и постепенном его сужении до одного элемента (в
случае дискретной функции) или допустимой погрешности (в случае непрерывной
функции). Сужение выполняется следующим образом:


- Текущие границы отрезка - $$[L;R]$$.
- Определим $$M$$ как середину отрезка: $$M = {L + R \over 2}$$.
- Найдём значение функции $$f(M)$$.
- Сравним это значение с $$y$$:
    - $$f(M) < y$$: из условия монотонности функции следует, что $$M < x$$, сужаем отрезок до $$(M;R]$$.
    - $$f(M) > y$$: из условия монотонности функции следует, что $$M > x$$, сужаем отрезок до $$[L;M)$$.
    - $$f(M) = y$$: $$M$$ - ответ.

(Здесь и далее предполагается, что функция возрастающая. Для убывающей функции
нужно "развернуть" знаки в некоторых местах).

Стоит заметить, что в некоторых случаях могут существовать несколько
значений $$x$$, таких что $$f(x) = y$$. В таком случае обычная реализация бинарного
поиска найдёт произвольное $$x$$, удовлетворяющее условию. Для определения границ
промежутка искомых значений $$x$$ нужно пользоваться модифицированным алгоритмом,
ищущим первое значение $$x$$, такое что $$f(x) = y$$ и первое значение $$x$$, такое
что $$f(x) > y$$. Этого мы ещё коснёмся в разделе реализаций бинарного поиска в
стандартной библиотеке C++.

### Реализация для непрерывной функции на C++

Для этого примера в качестве функции будем использовать возведение в квадрат:
$$f(x) = x^2$$. Нам нужно для заданного $$y$$ найти такое $$x$$, что $$x^2 = y$$. Можно
заметить, что это есть не что иное, как квадратный корень из $$y$$.

{% highlight cpp linenos %}
double binsearch_sqrt(double y) {
    double l = 0, r = 1e9;      //изначальные границы выбираются исходя из
                                //ограничений на данные в конкретной задаче

    while (r - l > 1e-6) {      //допустимая погрешность: 10^-6
        double m = (l + r) / 2;
        double cur = m * m;

        if (cur < y) {
            l = m;
        } else if (cur > y) {
            r = m;
        } else {
            return m;
        }
    }

    return l;   //l и r практически равны, поэтому неважно,
                //что из них считать ответом.
}
{% endhighlight %}


### Реализация для отсортированного массива как дискретной функции на C++
Самый распространённый пример бинарного поиска по дискретной функции -
поиск элемента в отсортированном массиве. Функцию можно записать в виде
$$f(x) = a_x$$, или $$f(x) = a[x]$$, где $$a$$ - отсортированный массив. Другими
словами, бинарный поиск по массиву позволяет найти индекс элемента с заданным
значением.

{% highlight cpp linenos %}
& a, int val) {
    int l = 0, r = a.size() - 1;

    while (r > l) {
        int m = (l + r) / 2;    //целочисленное деление!

        if (a[m] < val) {
            l = m + 1;
        } else if (a[m] > val) {
            r = m - 1;
        } else {
            return m;
        }
    }

    //l == r == искомый индекс

    //Если искомого элемента не было в массиве,
    //бинарный поиск найдёт следующий после него элемент.
    //Чтобы распознать этот случай, мы используем дополнительное сравнение.
    if (a[l] == val) {
        return l;
    } else {
        return -1;
    }
}
{% endhighlight %}


С дискретными функциями связано несколько тонких моментов, часто приводящих к
ошибкам, вызывающим зацикливание алгоритма. А именно: возможность использования
открытых или закрытых границ (включающих или исключающих элементы $$L$$ и $$R$$), и
целочисленного деления на два при поиске среднего элемента. Чтобы избежать ошибок,
нужно следовать одному простому правилу: новые границы всегда должны включать
элемент $$M + 1$$ или $$M - 1$$, но не включать элемент $$M$$. При выполнении этого
условия бинарный поиск будет работать корректно.

### Реализации бинарного поиска в стандартной библиотеке C++

В стандартной библиотеке C++ содержатся две основные функции реализующие бинарный
поиск на отсортированном массиве. Их определения:

{% highlight cpp linenos %}
//параметр value должен иметь тип, на который указывают итераторы.

//возвращает итератор на первый элемент, больший либо равный value
iterator std::lower_bound(iterator begin, iterator end, int value);

//возвращает итератор на первый элемент, строго больший value
iterator std::upper_bound(iterator begin, iterator end, int value);
{% endhighlight %}


Обе эти функции предполагают, что отрезок $$[begin;end)$$ отсортирован по
стандартному компаратору, в противном случае их поведение не определено.
Для нахождения самого элемента обычно используется функция std::lower_bound.
При наличии элемента, она вернёт итератор на него, а при отсутствии -
на следующий в порядке сортировки. Если value больше всех элементов
промежутка, функция вернёт итератор end.

Функция std::upper_bound используется в особых ситуациях, когда нужно найти
положение первого элемента, больше заданного.

Возвращаясь к ситуации наличия нескольких искомых элементов в массиве, с помощью
этих функций искомый промежуток можно записать следующим образом:

$$[lower\_bound(x); upper\_bound(x))$$

Для бинарного поиска по массиву, отсортированному по собственному компаратору
вы можете воспользоваться расширенной формой функций:

{% highlight cpp linenos %}
iterator lower_bound(iterator begin, iterator end, int value, comparator comp);
iterator upper_bound(iterator begin, iterator end, int value, comparator comp);
{% endhighlight %}


Вы также можете осуществлять бинарный поиск по библиотечным классам std::set и
std::map. Для этого используйте методы классов:

{% highlight cpp linenos %}
set<int> s;
// ...
set<int>::iterator it = s.lower_bound(k);

map<int, string> m;
// ...

// бинарный поиск для std::map ведётся по ключам
map<int, string>::iterator it = m.lower_bound(k);     
{% endhighlight %}


### Бинарный поиск по ответу

Бинарный поиск по ответу - распространённый подход при решении задач.
Часто применяется в задачах и подзадачах вида "найдите максимально возможное
количество чего-либо при котором выполняются определённые условия". Бинарный
поиск по ответу в таких задачах можно применять, когда выполняются следующие
условия:


- Если возможен ответ $$N$$, то гарантированно возможен и ответ $$N − 1$$.
- Если невозможен ответ $$N$$, то гарантированно невозможен и ответ $$N + 1$$.


В качестве примера рассмотрим следующую задачу: <a href="http://codeforces.com/contest/371/problem/C">CF 218 Div2 C. Гамбургеры</a>
Параметр, по которому мы выполняем бинарный поиск - количество
гамбургеров, которые Поликарп может приготовить. Реализуем соотвествующие
функции:

{% highlight cpp linenos %}
//Считаем, что входные данные уже введены.
long long nb, ns, nc;
long long pb, ps, pc;
long long r;

//Количество необходимых кусков хлеба, колбасы и сыра для одного гамбургера.
//Рассчитывается из строки рецепта.
long long tb, ts, tc;

//Возможно ли приготовить h гамбургеров.
bool possible(long long h) {
    long long cost_b = max(0ll, (tb * h - nb) * pb);
    long long cost_s = max(0ll, (ts * h - ns) * ps);
    long long cost_c = max(0ll, (tc * h - nc) * pc);

    return cost_b + cost_s + cost_c <= r;
}

//Можно заметить, что это не стандартный бинарный поиск
//по элементу, а поиск первого "невозможного" количества
//гамбургеров (аналог std::upper_bound).
//В реализации таких функций часто допускаются ошибки
//в строках подобных 32 и 34, но они быстро выявляются и
//исправляются тестированием на сэмплах.
long long max_possible() {
    long long l = 0, r = 1e14;

    while (l < r) {
        long long m = (l + r) / 2;

        if (possible(m)) {
            l = m + 1;
        } else {
            r = m;
        }
    }

    return l - 1;   //l == r == первое "невозможное" количество
}
{% endhighlight %}


<a href="http://codeforces.com/contest/371/submission/12605708">Полное решение этой задачи.</a>
