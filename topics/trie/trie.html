---
layout: topic
title: Бор
permalink: topics/trie
---

<h3>Опредение</h3>

<p>Бор, или префиксное дерево, &ndash; структура данных для эффективного хранения
и обработки строк. Вершины в боре соответствуют отдельным символам. В каждой
вершине хранится также числовое значение, обозначающее, сколько строк заканчиваются
в этой вершине. Строки представляются в виде путей по бору от корня (пустой строки)
до последнего символа.</p>

<img style="display: block; margin: auto" src="/resources/trie.png" />

<p>В боре, изображённом выше, хранятся следующие строки:</p>

<ul>
    <li>"to" &ndash; 7 экземпляров</li>
    <li>"tea" &ndash; 3 экземпляра</li>
    <li>"ted" &ndash; 4 экземпляра</li>
    <li>"ten" &ndash; 12 экземпляров</li>
    <li>"A" &ndash; 15 экземпляров</li>
    <li>"i" &ndash; 11 экземпляров</li>
    <li>"in" &ndash; 5 экземпляров</li>
    <li>"inn" &ndash; 9 экземпляров</li>
</ul>

<p>Таким образом, в каждой вершине бора хранится количество строк, заканчивающихся
в этой вершине, и указатели на дочерние вершины, каждая из которых соответствует
определённому символу.</p>

<h3>Реализация</h3>

<p>При реализации бора используются указатели и динамическое выделение памяти.
Предполагается владение этими концепциями языка C++.</p>

<p>Во всех предыдущих реализациях структур данных деревья представлялись или
в виде массива с формулами перехода, или в виде списка смежности. Для реализации
бора необходимо "реальное" представление деревьев, каждая вершина в которых &ndash;
отдельный элемент, которому соответствует собственный тип данных. В каждой вершине
хранится массив указателей на дочерние вершины.</p>

<p>Реализуем тип данных для представления вершин в дереве:</p>

<pre><code class="language-cpp line-numbers">struct node {
    node *next[26];     //Массив указателей на следующие вершины
                        //next[i] - указатель на следующую вершину, соответствующую символу ('a' + i)
                        //(предполагается, что используются только строчные латинские буквы)

    int strings;        //Количество строк, заканчивающихся в этой вершине.

    node() {
        for (int i = 0; i &lt; 26; i++) {   //изначально заполняем next нулевыми указателями,
            next[i] = nullptr;           //так как следующие вершины ещё не созданы
        }

        strings = 0;
    }
};
</code></pre>

<p>Для добавления в бор очередной строки, нужно создать все необходимые вершины,
если они ещё не созданы, и увеличить счётчик строк в последней вершине на $1$:</p>

<pre><code class="language-cpp line-numbers">node *root = new node();     //корневая вершина бора, соответствующая пустой строке.

void add(const string&amp; s) {
    node *cur_v = root;     //текущая вершина

    for (int i = 0; i &lt; s.length(); i++) {
        char c = s[i];

        if (cur_v->next[c - 'a'] == nullptr) {
            cur_v->next[c - 'a'] = new node();
        }

        cur_v = cur_v->next[c - 'a'];
    }

    cur_v->strings++;
}
</code></pre>

<p>Проверки наличия в боре строки реализуется похожим образом:</p>

<pre><code class="language-cpp line-numbers">bool has(const string&amp; s) {
    node *cur_v = root;

    for (int i = 0; i &lt; s.length(); i++) {
        cur_v = cur_v->next[s[i] - 'a'];
        if (cur_v == nullptr) {
            return false;
        }
    }

    return cur_v->strings > 0;
}
</code></pre>

<p>С бором можно выполнять множество операций, но большинство из них сводятся к обходу
всех строк с помощью DFS. Для примера давайте реализуем функцию, выводящую все строки,
содержащиеся в боре:</p>

<pre><code class="language-cpp line-numbers">string cur_str = "";

void write(node *v = root) {
    for (int i = 0; i &lt; v->strings; i++) {
        cout &lt;&lt; cur_str &lt;&lt; endl;
    }

    for (int i = 0; i &lt; 26; i++) {
        if (v->next[i] != nullptr) {
            cur_str.push_back('a' + i);
            write(v->next[i]);
            cur_str.pop_back();
        }
    }
}
</code></pre>

<h3>Применение</h3>

<p>Бор является достаточно легкомодифицируемой структурой данных, и в зависимости от
значений, хранимых в вершинах, и способа обхода с его помощью можно реализовать
множество различных операций. Конкретная реализация бора варьируется от задачи к
задаче.</p>

<p>Бор также используется как вспомогательная структура данных для более сложных
строковых алгоритмов, в частности, алгоритма Ахо-Корасик.</p>
