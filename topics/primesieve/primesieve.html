---
layout: topic
title: Решето Эратосфена
permalink: topics/primesieve
---

<h3>Определение</h3>

<p>Решето Эратосфена &ndash; достаточно эффективный алгоритм для нахождения
<em>всех</em> простых чисел в отрезке от $1$ до $N$ за $O(N \log \log N)$.</p>

<p>Алгоритм достаточно тривиален: будем перебирать числа по возрастанию,
начиная с $2$, зачёркивая все числа, кратные текущему. Например, при обработке
числа $2$ будут зачёркнуты числа $4, 6, 8, \ldots$. Если мы обнаружили
незачёркнутое число, это значит, что оно простое.</p>

<p>Визуализация работы решета Эратосфена:</p>

<img style="display: block; margin: auto" src="/resources/eratosthenes.gif" />

<p>Работу решета можно значительно ускорить, если начинать зачёркивать
числа, кратные $p$, не с $2p$, а с $p^2$. Ведь числа $2p, 3p, 5p, \ldots$ уже
были зачёркнуты при обработке чисел $2, 3, 5, \ldots$</p>

<h3>Реализация</h3>

<pre><code class="language-cpp line-numbers">#include &lt;bits/stdc++.h&gt;

using namespace std;

bool sieve[1000001];    //решето
vector&lt;int&gt; primes;     //вектор, в который будут добавляться простые числа

void compute_primes(int n) {
    for (int i = 2; i &lt;= n; i++) {   //Изначально все числа не вычеркнуты.
        sieve[i] = true;
    }

    for (int i = 2; i &lt;= n; i++) {
        if (sieve[i]) {     //если i не вычеркнуто
            primes.push_back(i);

            for (int j = i * i; j &lt;= n; j += i) {    //вычеркиваем все кратные числа начиная с i^2
                sieve[j] = false;
            }
        }
    }
}

int main() {
    compute_primes(1000000);

    cout &lt;&lt; "Prime numbers: ";
    for (int i: primes) {
        cout &lt;&lt; i &lt;&lt; ", ";
    }
}
</code></pre>
