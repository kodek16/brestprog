<h3>Определение</h3>

<p>Дерево Фенвика &ndash; простая в реализация, быстрая в работе, но совершенно
неочевидная в идее структура данных, позволяющая находить сумму на префиксе и
изменять отдельные элементы за $O(\log N)$. Несмотря на одинаковую сложность,
дерево Фенвика работает значительно быстрее дерева отрезков.</p>

<p>В этой лекции не будет приводится точный принцип работы дерева Фенвика,
будут приведены только реализация и способы использования.</p>

<h3>Алгоритм</h3>

<p>Дерево Фенвика, хотя и является по идее деревом, представляется в виде массива
$f$, в котором $f[i]$ &ndash; сумма элементов от $F(i)$ до $i$.</p>

<p>Функция $F(x)$ связана с битовым представлением числа $x$. Её можно описать
следующим образом: $F(x)$ заменяет группу единичных битов, находящихся в конце
числа (младших) на нули. Если $x$ заканчивается на нулевой бит, то $F(x) = x$.
С помощью битовых операций $F(x)$ записывается следующим образом:</p>

$$F(x) = x\ and\ (x + 1)$$

<p>Значит, функцию нахождения суммы на промежутке $[0; x]$ можно реализовать
следующим образом:</p>

<pre><code class="language-cpp line-numbers">int sum(int x) {
    int result = 0;

    for (; x >= 0; x = (x &amp; (x + 1)) - 1) {
        result += f[x];
    }

    return result;
}
</code></pre>

<p>Осталось понять, как обновлять значения дерева Фенвика при изменении элемента.
При изменении элемента $i$ нужно обновить все $f[j]$, где $F(j) \le i \le j$.
Оказывается, последовательность $j$ выглядит следующим образом:</p>

$$j_0 = i \\
j_i = j_{i - 1}\ or\ (j_{i - 1} + 1)$$

<p>Значит, обновление элемента реализуется следующим образом:</p>

<pre><code class="language-cpp line-numbers">//Увеличить a[idx] на delta
void increase(int idx, int delta) {
    a[idx] += delta;

    for (; idx &lt; n; idx |= idx + 1) {
        f[idx] += delta;
    }
}
</code></pre>

<h3>Реализация</h3>

<pre><code class="language-cpp line-numbers">#include &lt;bits/stdc++.h&gt;

using namespace std;

int n;
int a[100000];  //массив
int f[100000];  //дерево Фенвика

//сумма элементов от 0 до x
int sum(int x) {
    int result = 0;

    for (; x >= 0; x = (x &amp; (x + 1)) - 1) {
        result += f[x];
    }

    return result;
}

//сумма элементов от l до r
int sum(int l, int r) {
    if (l) {
        return sum(r) - sum(l - 1);
    } else {
        return sum(r);
    }
}

//увеличение a[idx] на delta
void increase(int idx, int delta) {
    a[idx] += delta;

    for (; idx &lt; n; idx |= idx + 1) {
        f[idx] += delta;
    }
}

int main() {
    cin >> n;

    for (int i = 0; i &lt; n; i++) {    //ввод массива и заполнение дерева Фенвика
        int t;
        cin >> t;
        increase(i, t);
    }

    //Можем обрабатывать запросы
}
</code></pre>

<h3>Дерево Фенвика для поиска минимума/максимума на префиксе</h3>

<p>С помощью дерева Фенвика также можно поддерживать минимумы/максимумы на
префиксах, но поддерживаемые операции такого дерева значительно ограничиваются:</p>

<ul>
    <li>По значениям минимума/максимума на префиксе невозможно установить значение
    на произвольном отрезке.</li>

    <li>Возможно только уменьшение (дерево для поиска минимума)/увеличение (дерево для
    поиска максимума) элементов.</li>
</ul>

<p>Реализация почти совпадает с реализацией для поиска суммы:</p>

<pre><code class="language-cpp line-numbers">#include &lt;bits/stdc++.h&gt;

using namespace std;

int n;
int a[100000];  //массив
int f[100000];  //дерево Фенвика

//минимум среди элементов от 0 до x
int get_min(int x) {
    int result = INT_MAX;

    for (; x >= 0; x = (x &amp; (x + 1)) - 1) {
        result = min(result, f[x]);
    }

    return result;
}

//присваивание a[idx] = val (val &lt;= a[idx])
void assign(int idx, int val) {
    a[idx] = val;

    for (; idx &lt; n; idx |= idx + 1) {
        f[idx] = min(f[idx], val);
    }
}

int main() {
    cin >> n;

    for (int i = 0; i &lt; n; i++) {       //Изначально принимаем все значения в дереве
        f[i] = INT_MAX;                 //равными бесконечности, так как далее их можно
    }                                   //только уменьшать.

    for (int i = 0; i &lt; n; i++) {    //ввод массива и заполнение дерева Фенвика
        int t;
        cin >> t;
        assign(i, t);
    }

    //Можем обрабатывать запросы.
}
</code></pre>

<h3>Решение задачи о наибольшей возрастающей последовательности с помощью дерева Фенвика на максимумы</h3>

<p>Эта задача уже разбиралась в лекции про динамическое программирование, и мы
упоминали, что её можно решать за $O(N \log N)$ с помощью дерева Фенвика. Разберём
это решение.</p>

<p>Для решения важно ограничение на элементы последовательности. Если $a_i \le 10^6$,
то задачу можно решать с помощью дерева Фенвика, иначе, необходимо сначала "сжать"
значения (заменить каждое значение на его индекс в порядке сортировки).</p>

<p>Идея решения достаточно простая: будем идти по последовательности слева
направо, поддерживая массив $f$, где $f[i]$ &ndash; длина наибольшей
возрастающей подпоследовательности, заканчивающейся на число $i$. Изначально
$f[i] = 0$ для всех $i$.</p>

<p>При обработке очередного элемента, пытаемся улучшить длину подпоследовательности,
на него заканчивающейся. Для этого мы можем продолжить последовательность любой
меньшей длины, или начать новую. В виде формулы это можно записать так (текущий
элемент равен $x$):</p>

$$f[x] = \max(f[x], \max\limits_{i = 0}^{x - 1} f[i] + 1)$$

<p>Заметим в формуле максимум на префиксе. Если находить его с помощью дерева
Фенвика за $O(\log N)$, можно решать задачу за $O(N \log N)$.</p>

<p>Ответом на задачу будет максимум по всем $f$.</p>

<p>Реализация на C++:</p>

<pre><code class="language-cpp line-numbers">#include &lt;bits/stdc++.h&gt;

using namespace std;

int n;
int seq[100000];  //последовательность

int a[1000001];  //массив, соответствующий дереву Фенвика
int f[1000001];  //дерево Фенвика

int get_max(int x) {
    int result = INT_MIN;

    for (; x >= 0; x = (x &amp; (x + 1)) - 1) {
        result = max(result, f[x]);
    }

    return result;
}

//(val &gt;= a[idx])
void assign(int idx, int val) {
    a[idx] = val;

    for (; idx &lt;= 1000000; idx |= idx + 1) {
        f[idx] = max(f[idx], val);
    }
}

int main() {
    cin >> n;

    for (int i = 0; i &lt; n; i++) {
        cin >> seq[i];
    }

    for (int i = 0; i &lt; n; i++) {
        int x = seq[i];
        int prev_max = get_max(x - 1);  //максимальная длина, которую можно продолжить

        if (prev_max + 1 > a[x]) {
            assign(x, prev_max + 1);
        }
    }

    int ans = get_max(1000000);
    cout &lt;&lt; ans &lt;&lt; endl;
}
</code></pre>

<h3>Обобщение дерева Фенвика на несколько измерений</h3>

<p>Ещё одно преимущество дерева Фенвика перед деревом отрезков &ndash; абсолютно
тривиальный способ обобщения на несколько измерений (сложность запроса для
$K$-мерного дерева Фенвика равна $O(2^k * \log^k N)$). В качестве примера
приведём реализацию двумерного дерева Фенвика для нахождения суммы на "префиксе"
матрицы:</p>

<pre><code class="language-cpp line-numbers">#include &lt;bits/stdc++.h&gt;

using namespace std;

int n, m;
int a[1000][1000];  //матрица
int f[1000][1000];  //дерево Фенвика

//сумма элементов от (0, 0) до (x, y)
int sum(int x, int y) {
    if (x &lt; 0 || y &lt; 0) {
        return 0;
    }

    int result = 0;

    for (int i = x; i >= 0; i = (i &amp; (i + 1)) - 1) {
        for (int j = y; j >= 0; j = (j &amp; (j + 1)) - 1) {
            result += f[i][j];
        }
    }

    return result;
}

//сумма элементов от (x1, y1) до (x2, y2)
//(разбирается в лекции про префиксные суммы)
int sum(int x1, int y1, int x2, int y2) {
    return sum(x2, y2)
         - sum(x1 - 1, y2)
         - sum(x2, y1 - 1)
         + sum(x1 - 1, y1 - 1);
}

//увеличение a[x][y] на delta
void increase(int x, int y, int delta) {
    a[x][y] += delta;

    for (int i = x; i &lt; n; i |= i + 1) {
        for (int j = y; j &lt; m; j |= j + 1) {
            f[i][j] += delta;
        }
    }
}

int main() {
    cin >> n >> m;

    for (int i = 0; i &lt; n; i++) {    //ввод массива и заполнение дерева Фенвика
        for (int j = 0; j &lt; m; j++) {
            int t;
            cin >> t;
            increase(i, j, t);
        }
    }

    //Можем обрабатывать запросы
}
</code></pre>
